#!/usr/bin/env node
'use strict';

var commander = require('commander');
var which = require('which');
var listr2 = require('listr2');
var chalk = require('chalk');
var path2 = require('path');
var fastify = require('fastify');
var fs5 = require('fs');
var Ajv = require('ajv');
var addErrors = require('ajv-errors');
var test = require('@playwright/test');
var util = require('util');
var winston = require('winston');
var FormData = require('form-data');
var axios = require('axios');
var https = require('https');
var child_process = require('child_process');
var spawn = require('cross-spawn');
var NodeCache = require('node-cache');
var uuid = require('uuid');
var sharp = require('sharp');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var which__default = /*#__PURE__*/_interopDefault(which);
var chalk__default = /*#__PURE__*/_interopDefault(chalk);
var path2__default = /*#__PURE__*/_interopDefault(path2);
var fastify__default = /*#__PURE__*/_interopDefault(fastify);
var fs5__default = /*#__PURE__*/_interopDefault(fs5);
var Ajv__default = /*#__PURE__*/_interopDefault(Ajv);
var addErrors__default = /*#__PURE__*/_interopDefault(addErrors);
var FormData__default = /*#__PURE__*/_interopDefault(FormData);
var axios__default = /*#__PURE__*/_interopDefault(axios);
var https__default = /*#__PURE__*/_interopDefault(https);
var spawn__default = /*#__PURE__*/_interopDefault(spawn);
var NodeCache__default = /*#__PURE__*/_interopDefault(NodeCache);
var sharp__default = /*#__PURE__*/_interopDefault(sharp);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/lib/constants.ts
var constants_default = {
  // default configs
  DEFAULT_CONFIG: {
    web: {
      browsers: [
        "chrome",
        "firefox",
        "safari",
        "edge"
      ],
      viewports: [
        [1920],
        [1366],
        [1028]
      ]
    },
    mobile: {
      devices: [
        "iPhone 14",
        "Galaxy S24"
      ],
      fullPage: true,
      orientation: "portrait"
    },
    waitForTimeout: 1e3,
    enableJavaScript: false,
    allowedHostnames: [],
    smartIgnore: false
  },
  DEFAULT_WEB_STATIC_CONFIG: [
    {
      "name": "lambdatest-home-page",
      "url": "https://www.lambdatest.com",
      "waitForTimeout": 1e3
    },
    {
      "name": "example-page",
      "url": "https://example.com/"
    }
  ],
  // browsers
  CHROME: "chrome",
  SAFARI: "safari",
  FIREFOX: "firefox",
  EDGE: "edge",
  EDGE_CHANNEL: "msedge",
  WEBKIT: "webkit",
  // discovery browser launch arguments
  LAUNCH_ARGS: [
    // disable the translate popup and optimization downloads
    "--disable-features=Translate,OptimizationGuideModelDownloading",
    // disable several subsystems which run network requests in the background
    "--disable-background-networking",
    // disable task throttling of timer tasks from background pages
    "--disable-background-timer-throttling",
    // disable backgrounding renderer processes
    "--disable-renderer-backgrounding",
    // disable backgrounding renderers for occluded windows (reduce nondeterminism)
    "--disable-backgrounding-occluded-windows",
    // disable crash reporting
    "--disable-breakpad",
    // disable client side phishing detection
    "--disable-client-side-phishing-detection",
    // disable default component extensions with background pages for performance
    "--disable-component-extensions-with-background-pages",
    // disable installation of default apps on first run
    "--disable-default-apps",
    // work-around for environments where a small /dev/shm partition causes crashes
    "--disable-dev-shm-usage",
    // disable extensions
    "--disable-extensions",
    // disable hang monitor dialogs in renderer processes
    "--disable-hang-monitor",
    // disable inter-process communication flooding protection for javascript
    "--disable-ipc-flooding-protection",
    // disable web notifications and the push API
    "--disable-notifications",
    // disable the prompt when a POST request causes page navigation
    "--disable-prompt-on-repost",
    // disable syncing browser data with google accounts
    "--disable-sync",
    // disable site-isolation to make network requests easier to intercept
    "--disable-site-isolation-trials",
    // disable the first run tasks, whether or not it's actually the first run
    "--no-first-run",
    // disable the sandbox for all process types that are normally sandboxed
    "--no-sandbox",
    // specify a consistent encryption backend across platforms
    "--password-store=basic",
    // use a mock keychain on Mac to prevent blocking permissions dialogs
    "--use-mock-keychain",
    // enable remote debugging on the first available port
    "--remote-debugging-port=0",
    // sets navigator.webdriver to false
    "--disable-blink-features=AutomationControlled",
    // disable UA-CH feature
    `--disable-features=UserAgentClientHint`
  ],
  // discovery request headers
  REQUEST_HEADERS: {
    // `HeadlessChrome` is added to sec-ch-ua, `--disable-features=UserAgentClientHint` doesn't seem to work
    "sec-ch-ua": '"Chromium";v="129", "Not=A?Brand";v="8"',
    "sec-ch-ua-mobile": '"?0"',
    "sec-ch-ua-platform": '"Windows"'
  },
  // user agents
  CHROME_USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.107 Safari/537.3",
  FIREFOX_USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:112.0) Gecko/20100101 Firefox/112.0",
  SAFARI_USER_AGENT: "Mozilla/5.0 (Macintosh; Intel Mac OS X 13_3) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15",
  EDGE_USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.35",
  // viewports
  MIN_VIEWPORT_HEIGHT: 1080,
  // mobile
  MOBILE_OS_ANDROID: "android",
  MOBILE_OS_IOS: "ios",
  MOBILE_ORIENTATION_PORTRAIT: "portrait",
  MOBILE_ORIENTATION_LANDSCAPE: "landscape",
  // build status
  BUILD_COMPLETE: "completed",
  BUILD_ERROR: "error",
  // CI
  GITHUB_API_HOST: "https://api.github.com",
  // log file path
  LOG_FILE_PATH: ".smartui.log",
  // Disallowed file extension
  FILE_EXTENSION_ZIP: ".zip",
  FILE_EXTENSION_GIFS: "gif",
  // Default scrollTime
  DEFAULT_SCROLL_TIME: 8,
  // Default page load time
  DEFAULT_PAGE_LOAD_TIMEOUT: 18e4,
  // Magic Numbers 
  MAGIC_NUMBERS: [
    { ext: "jpg", magic: Buffer.from([255, 216, 255]) },
    { ext: "jpeg", magic: Buffer.from([255, 216, 255]) },
    { ext: "png", magic: Buffer.from([137, 80, 78, 71, 13, 10, 26, 10]) },
    { ext: "gif", magic: Buffer.from([71, 73, 70, 56]) }
  ],
  SUPPORTED_MOBILE_DEVICES: {
    "Blackberry KEY2 LE": { os: "android", viewport: { width: 412, height: 618 } },
    "Galaxy A12": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy A21s": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A22": { os: "android", viewport: { width: 358, height: 857 } },
    "Galaxy A31": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A32": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A51": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A7": { os: "android", viewport: { width: 412, height: 846 } },
    "Galaxy A70": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A8": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy A8 Plus": { os: "android", viewport: { width: 412, height: 846 } },
    "Galaxy J7 Prime": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy M12": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy M31": { os: "android", viewport: { width: 412, height: 892 } },
    "Galaxy Note10": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy Note10 Plus": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy Note20": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy Note20 Ultra": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy S10": { os: "android", viewport: { width: 360, height: 760 } },
    "Galaxy S10 Plus": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy S10e": { os: "android", viewport: { width: 412, height: 740 } },
    "Galaxy S20": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy S20 FE": { os: "android", viewport: { width: 412, height: 914 } },
    "Galaxy S20 Ultra": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy S20 Plus": { os: "android", viewport: { width: 384, height: 854 } },
    "Galaxy S21": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy S21 FE": { os: "android", viewport: { width: 360, height: 780 } },
    "Galaxy S21 Ultra": { os: "android", viewport: { width: 384, height: 854 } },
    "Galaxy S21 Plus": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy S22": { os: "android", viewport: { width: 360, height: 780 } },
    "Galaxy S22 Ultra": { os: "android", viewport: { width: 384, height: 854 } },
    "Galaxy S23": { os: "android", viewport: { width: 360, height: 645 } },
    "Galaxy S23 Plus": { os: "android", viewport: { width: 360, height: 648 } },
    "Galaxy S23 Ultra": { os: "android", viewport: { width: 384, height: 689 } },
    "Galaxy S24": { os: "android", viewport: { width: 360, height: 780 } },
    "Galaxy S24 Plus": { os: "android", viewport: { width: 384, height: 832 } },
    "Galaxy S24 Ultra": { os: "android", viewport: { width: 384, height: 832 } },
    "Galaxy S7": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy S7 Edge": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy S8": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy S8 Plus": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy S9": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy S9 Plus": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy Tab A7 Lite": { os: "android", viewport: { width: 534, height: 894 } },
    "Galaxy Tab A8": { os: "android", viewport: { width: 800, height: 1280 } },
    "Galaxy Tab S3": { os: "android", viewport: { width: 1024, height: 768 } },
    "Galaxy Tab S4": { os: "android", viewport: { width: 712, height: 1138 } },
    "Galaxy Tab S7": { os: "android", viewport: { width: 800, height: 1192 } },
    "Galaxy Tab S8": { os: "android", viewport: { width: 753, height: 1205 } },
    "Galaxy Tab S8 Plus": { os: "android", viewport: { width: 825, height: 1318 } },
    "Huawei Mate 20 Pro": { os: "android", viewport: { width: 360, height: 780 } },
    "Huawei P20 Pro": { os: "android", viewport: { width: 360, height: 747 } },
    "Huawei P30": { os: "android", viewport: { width: 360, height: 780 } },
    "Huawei P30 Pro": { os: "android", viewport: { width: 360, height: 780 } },
    "Microsoft Surface Duo": { os: "android", viewport: { width: 1114, height: 705 } },
    "Moto G7 Play": { os: "android", viewport: { width: 360, height: 760 } },
    "Moto G9 Play": { os: "android", viewport: { width: 393, height: 786 } },
    "Moto G Stylus (2022)": { os: "android", viewport: { width: 432, height: 984 } },
    "Nexus 5": { os: "android", viewport: { width: 360, height: 640 } },
    "Nexus 5X": { os: "android", viewport: { width: 412, height: 732 } },
    "Nokia 5": { os: "android", viewport: { width: 360, height: 640 } },
    "Nothing Phone (1)": { os: "android", viewport: { width: 412, height: 915 } },
    "OnePlus 10 Pro": { os: "android", viewport: { width: 412, height: 919 } },
    "OnePlus 11": { os: "android", viewport: { width: 360, height: 804 } },
    "OnePlus 6": { os: "android", viewport: { width: 412, height: 869 } },
    "OnePlus 6T": { os: "android", viewport: { width: 412, height: 892 } },
    "OnePlus 7": { os: "android", viewport: { width: 412, height: 892 } },
    "OnePlus 7T": { os: "android", viewport: { width: 412, height: 914 } },
    "OnePlus 8": { os: "android", viewport: { width: 412, height: 915 } },
    "OnePlus 9": { os: "android", viewport: { width: 411, height: 915 } },
    "OnePlus 9 Pro": { os: "android", viewport: { width: 412, height: 919 } },
    "OnePlus Nord": { os: "android", viewport: { width: 412, height: 914 } },
    "OnePlus Nord 2": { os: "android", viewport: { width: 412, height: 915 } },
    "OnePlus Nord CE": { os: "android", viewport: { width: 412, height: 915 } },
    "Oppo A12": { os: "android", viewport: { width: 360, height: 760 } },
    "Oppo A15": { os: "android", viewport: { width: 360, height: 800 } },
    "Oppo A54": { os: "android", viewport: { width: 360, height: 800 } },
    "Oppo A5s": { os: "android", viewport: { width: 360, height: 760 } },
    "Oppo F17": { os: "android", viewport: { width: 360, height: 800 } },
    "Oppo K10": { os: "android", viewport: { width: 360, height: 804 } },
    "Pixel 3": { os: "android", viewport: { width: 412, height: 823 } },
    "Pixel 3 XL": { os: "android", viewport: { width: 412, height: 846 } },
    "Pixel 3a": { os: "android", viewport: { width: 412, height: 823 } },
    "Pixel 4": { os: "android", viewport: { width: 392, height: 830 } },
    "Pixel 4 XL": { os: "android", viewport: { width: 412, height: 823 } },
    "Pixel 4a": { os: "android", viewport: { width: 393, height: 851 } },
    "Pixel 5": { os: "android", viewport: { width: 393, height: 851 } },
    "Pixel 6": { os: "android", viewport: { width: 393, height: 786 } },
    "Pixel 6 Pro": { os: "android", viewport: { width: 412, height: 892 } },
    "Pixel 7": { os: "android", viewport: { width: 412, height: 915 } },
    "Pixel 7 Pro": { os: "android", viewport: { width: 412, height: 892 } },
    "Pixel 8": { os: "android", viewport: { width: 412, height: 915 } },
    "Pixel 8 Pro": { os: "android", viewport: { width: 448, height: 998 } },
    "Poco M2 Pro": { os: "android", viewport: { width: 393, height: 873 } },
    "POCO X3 Pro": { os: "android", viewport: { width: 393, height: 873 } },
    "Realme 5i": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme 7i": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme 8i": { os: "android", viewport: { width: 360, height: 804 } },
    "Realme C21Y": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme C21": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme GT2 Pro": { os: "android", viewport: { width: 360, height: 804 } },
    "Redmi 8": { os: "android", viewport: { width: 360, height: 760 } },
    "Redmi 9": { os: "android", viewport: { width: 360, height: 800 } },
    "Redmi 9C": { os: "android", viewport: { width: 360, height: 800 } },
    "Redmi Note 10 Pro": { os: "android", viewport: { width: 393, height: 873 } },
    "Redmi Note 8": { os: "android", viewport: { width: 393, height: 851 } },
    "Redmi Note 8 Pro": { os: "android", viewport: { width: 393, height: 851 } },
    "Redmi Note 9": { os: "android", viewport: { width: 393, height: 851 } },
    "Redmi Note 9 Pro Max": { os: "android", viewport: { width: 393, height: 873 } },
    "Redmi Y2": { os: "android", viewport: { width: 360, height: 720 } },
    "Tecno Spark 7": { os: "android", viewport: { width: 360, height: 800 } },
    "Vivo Y22": { os: "android", viewport: { width: 385, height: 860 } },
    "Vivo T1": { os: "android", viewport: { width: 393, height: 873 } },
    "Vivo V7": { os: "android", viewport: { width: 360, height: 720 } },
    "Vivo Y11": { os: "android", viewport: { width: 360, height: 722 } },
    "Vivo Y12": { os: "android", viewport: { width: 360, height: 722 } },
    "Vivo Y20g": { os: "android", viewport: { width: 385, height: 854 } },
    "Vivo Y50": { os: "android", viewport: { width: 393, height: 786 } },
    "Xiaomi 12 Pro": { os: "android", viewport: { width: 412, height: 915 } },
    "Xperia Z5": { os: "android", viewport: { width: 360, height: 640 } },
    "Xperia Z5 Dual": { os: "android", viewport: { width: 360, height: 640 } },
    "Zenfone 6": { os: "android", viewport: { width: 412, height: 892 } },
    "iPad 10.2 (2019)": { os: "ios", viewport: { width: 810, height: 1080 } },
    "iPad 10.2 (2020)": { os: "ios", viewport: { width: 834, height: 1194 } },
    "iPad 10.2 (2021)": { os: "ios", viewport: { width: 810, height: 1080 } },
    "iPad 9.7 (2017)": { os: "ios", viewport: { width: 768, height: 1024 } },
    "iPad Air (2019)": { os: "ios", viewport: { width: 834, height: 1112 } },
    "iPad Air (2020)": { os: "ios", viewport: { width: 820, height: 1180 } },
    "iPad Air (2022)": { os: "ios", viewport: { width: 820, height: 1180 } },
    "iPad mini (2019)": { os: "ios", viewport: { width: 768, height: 1024 } },
    "iPad mini (2021)": { os: "ios", viewport: { width: 744, height: 1133 } },
    "iPad Pro 11 (2021)": { os: "ios", viewport: { width: 834, height: 1194 } },
    "iPad Pro 11 (2022)": { os: "ios", viewport: { width: 834, height: 1194 } },
    "iPad Pro 12.9 (2018)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Pro 12.9 (2020)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Pro 12.9 (2021)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Pro 12.9 (2022)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPhone 11": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone 11 Pro": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone 11 Pro Max": { os: "ios", viewport: { width: 414, height: 896 } },
    "iPhone 12": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 12 Mini": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone 12 Pro": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 12 Pro Max": { os: "ios", viewport: { width: 428, height: 926 } },
    "iPhone 13": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 13 Mini": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 13 Pro": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 13 Pro Max": { os: "ios", viewport: { width: 428, height: 926 } },
    "iPhone 14": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 14 Plus": { os: "ios", viewport: { width: 428, height: 926 } },
    "iPhone 14 Pro": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 14 Pro Max": { os: "ios", viewport: { width: 428, height: 928 } },
    "iPhone 15": { os: "ios", viewport: { width: 393, height: 852 } },
    "iPhone 15 Plus": { os: "ios", viewport: { width: 430, height: 932 } },
    "iPhone 15 Pro": { os: "ios", viewport: { width: 393, height: 852 } },
    "iPhone 15 Pro Max": { os: "ios", viewport: { width: 430, height: 932 } },
    "iPhone 6": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 6s": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 6s Plus": { os: "ios", viewport: { width: 414, height: 736 } },
    "iPhone 7": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 7 Plus": { os: "ios", viewport: { width: 414, height: 736 } },
    "iPhone 8": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 8 Plus": { os: "ios", viewport: { width: 414, height: 736 } },
    "iPhone SE (2016)": { os: "ios", viewport: { width: 320, height: 568 } },
    "iPhone SE (2020)": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone SE (2022)": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone X": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone XR": { os: "ios", viewport: { width: 414, height: 896 } },
    "iPhone XS": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone XS Max": { os: "ios", viewport: { width: 414, height: 896 } },
    "Galaxy A10s": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy A11": { os: "android", viewport: { width: 412, height: 732 } },
    "Galaxy A13": { os: "android", viewport: { width: 412, height: 732 } },
    "Galaxy A52s 5G": { os: "android", viewport: { width: 384, height: 718 } },
    "Galaxy A53 5G": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy Tab A 10.1 (2019)": { os: "android", viewport: { width: 800, height: 1280 } },
    "Galaxy Tab S9": { os: "android", viewport: { width: 753, height: 1069 } },
    "Honor X9a 5G": { os: "android", viewport: { width: 360, height: 678 } },
    "Huawei P30 Lite": { os: "android", viewport: { width: 360, height: 647 } },
    "Huawei P50 Pro": { os: "android", viewport: { width: 412, height: 915 } },
    "iPad Pro 13 (2024)": { os: "ios", viewport: { width: 1032, height: 1376 } },
    "iPad Pro 11 (2024)": { os: "ios", viewport: { width: 834, height: 1210 } },
    "iPad Air 13 (2024)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Air 11 (2024)": { os: "ios", viewport: { width: 820, height: 1180 } },
    "iPad 10.9 (2022)": { os: "ios", viewport: { width: 820, height: 1180 } },
    "iPhone 16": { os: "ios", viewport: { width: 393, height: 852 } },
    "iPhone 16 Plus": { os: "ios", viewport: { width: 430, height: 932 } },
    "iPhone 16 Pro": { os: "ios", viewport: { width: 402, height: 874 } },
    "iPhone 16 Pro Max": { os: "ios", viewport: { width: 440, height: 956 } },
    "Motorola Edge 40": { os: "android", viewport: { width: 412, height: 915 } },
    "Motorola Edge 30": { os: "android", viewport: { width: 432, height: 814 } },
    "Moto G22": { os: "android", viewport: { width: 412, height: 767 } },
    "Moto G54 5G": { os: "android", viewport: { width: 432, height: 810 } },
    "Moto G71 5G": { os: "android", viewport: { width: 412, height: 732 } },
    "Pixel Tablet": { os: "android", viewport: { width: 800, height: 1100 } },
    "Pixel 6a": { os: "android", viewport: { width: 412, height: 766 } },
    "Pixel 7a": { os: "android", viewport: { width: 412, height: 766 } },
    "Pixel 9": { os: "android", viewport: { width: 412, height: 924 } },
    "Pixel 9 Pro": { os: "android", viewport: { width: 412, height: 915 } },
    "Pixel 9 Pro XL": { os: "android", viewport: { width: 448, height: 998 } },
    "Redmi 9A": { os: "android", viewport: { width: 360, height: 800 } },
    "Redmi Note 13 Pro": { os: "android", viewport: { width: 412, height: 869 } },
    "Aquos Sense 5G": { os: "android", viewport: { width: 393, height: 731 } },
    "Xperia 10 IV": { os: "android", viewport: { width: 412, height: 832 } },
    "Honeywell CT40": { os: "android", viewport: { width: 360, height: 512 } }
  },
  FIGMA_API: "https://api.figma.com/v1/",
  DEFAULT_FIGMA_CONFIG: {
    "depth": 2,
    "figma_config": [
      {
        "figma_file_token": "token_for_first_figma_file",
        "figma_ids": [
          "id1",
          "id2"
        ]
      }
    ]
  },
  WEB_FIGMA_CONFIG: {
    web: {
      browsers: [
        "chrome",
        "firefox",
        "safari",
        "edge"
      ]
    },
    figma: {
      "depth": 2,
      "configs": [
        {
          "figma_file_token": "<token>",
          "figma_ids": ["id-1", "id-2"],
          "screenshot_names": ["homepage", "about"]
        },
        {
          "figma_file_token": "<token>",
          "figma_ids": ["id-3", "id-4"],
          "screenshot_names": ["xyz", "abc"]
        }
      ]
    }
  },
  APP_FIGMA_CONFIG: {
    mobile: [
      {
        "name": "Pixel 8",
        "platform": ["android 14"]
      },
      {
        "name": "iPhone 15",
        "platform": ["ios 17"]
      }
    ],
    figma: {
      "depth": 2,
      "configs": [
        {
          "figma_file_token": "<token>",
          "figma_ids": ["id-1", "id-2"],
          "screenshot_names": ["homepage", "about"]
        },
        {
          "figma_file_token": "<token>",
          "figma_ids": ["id-3", "id-4"],
          "screenshot_names": ["xyz", "abc"]
        }
      ]
    }
  }
};

// src/lib/schemaValidation.ts
var ajv = new Ajv__default.default({ allErrors: true });
ajv.addFormat("web-url", {
  type: "string",
  validate: (url) => {
    try {
      new URL(url.trim());
      return true;
    } catch (error) {
      return false;
    }
  }
});
addErrors__default.default(ajv);
var ConfigSchema = {
  type: "object",
  properties: {
    web: {
      type: "object",
      properties: {
        browsers: {
          type: "array",
          items: { type: "string", enum: [constants_default.CHROME, constants_default.FIREFOX, constants_default.SAFARI, constants_default.EDGE] },
          uniqueItems: true,
          maxItems: 4,
          errorMessage: `Invalid config; allowed browsers - ${constants_default.CHROME}, ${constants_default.FIREFOX}, ${constants_default.SAFARI}, ${constants_default.EDGE}`
        },
        viewports: {
          type: "array",
          items: {
            type: "array",
            oneOf: [
              {
                items: [{ type: "number", minimum: 320, maximum: 7680 }],
                minItems: 1,
                maxItems: 1
              },
              {
                items: [
                  { type: "number", minimum: 320, maximum: 7680 },
                  { type: "number", minimum: 320, maximum: 7680 }
                ],
                minItems: 2,
                maxItems: 2
              }
            ],
            errorMessage: "Invalid config; width/height must be >= 320 and <= 7680"
          },
          uniqueItems: true,
          maxItems: 5,
          errorMessage: "Invalid config; max unique viewports allowed - 5"
        }
      },
      required: ["browsers", "viewports"],
      additionalProperties: false
    },
    mobile: {
      type: "object",
      properties: {
        devices: {
          type: "array",
          items: {
            type: "string",
            enum: Object.keys(constants_default.SUPPORTED_MOBILE_DEVICES),
            minLength: 1,
            errorMessage: {
              enum: "Invalid config; unsupported mobile devices",
              minLength: "Invalid config; mobile device cannot be empty"
            }
          },
          uniqueItems: true,
          maxItems: 20,
          errorMessage: {
            uniqueItems: "Invalid config; duplicate mobile devices",
            maxItems: "Invalid config; max mobile devices allowed - 20"
          }
        },
        fullPage: {
          type: "boolean",
          errorMessage: "Invalid config; fullPage must be true/false"
        },
        orientation: {
          type: "string",
          enum: [constants_default.MOBILE_ORIENTATION_PORTRAIT, constants_default.MOBILE_ORIENTATION_LANDSCAPE],
          errorMessage: `Invalid config; orientation must be ${constants_default.MOBILE_ORIENTATION_PORTRAIT}/${constants_default.MOBILE_ORIENTATION_LANDSCAPE}`
        }
      },
      required: ["devices"],
      additionalProperties: false
    },
    waitForPageRender: {
      type: "number",
      minimum: 0,
      maximum: 3e5,
      errorMessage: "Invalid config; waitForPageRender must be > 0 and <= 300000"
    },
    waitForTimeout: {
      type: "number",
      minimum: 0,
      maximum: 3e4,
      errorMessage: "Invalid config; waitForTimeout must be > 0 and <= 30000"
    },
    waitForDiscovery: {
      type: "number",
      minimum: 0,
      maximum: 18e5,
      errorMessage: "Invalid config; waitForDiscovery must be > 0 and <= 1800000"
    },
    enableJavaScript: {
      type: "boolean",
      errorMessage: "Invalid config; enableJavaScript must be true/false"
    },
    cliEnableJavaScript: {
      type: "boolean",
      errorMessage: "Invalid config; cliEnableJavaScript must be true/false"
    },
    smartIgnore: {
      type: "boolean",
      errorMessage: "Invalid config; smartIgnore must be true/false"
    },
    ignoreHTTPSErrors: {
      type: "boolean",
      errorMessage: "Invalid config; ignoreHttpsError must be true/false"
    },
    scrollTime: {
      type: "number",
      minimum: 1,
      maximum: 1e3,
      errorMessage: "Invalid config; scrollTime must be > 1 and <= 1000"
    },
    allowedHostnames: {
      type: "array",
      items: {
        type: "string",
        minLength: 1,
        errorMessage: {
          minLength: "Invalid config; allowed hostname cannot be empty"
        }
      },
      uniqueItems: true,
      errorMessage: {
        uniqueItems: "Invalid config; duplicates in allowedHostnames"
      }
    },
    allowedAssets: {
      type: "array",
      items: {
        type: "string",
        minLength: 1,
        errorMessage: {
          minLength: "Invalid config; allowedAssets cannot be empty"
        }
      },
      uniqueItems: true,
      errorMessage: {
        uniqueItems: "Invalid config; duplicates in allowedAssets"
      }
    },
    basicAuthorization: {
      type: "object",
      properties: {
        username: {
          type: "string",
          errorMessage: "Invalid config; username is mandatory"
        },
        password: {
          type: "string",
          errorMessage: "Invalid config; password is mandatory"
        }
      }
    },
    delayedUpload: {
      type: "boolean",
      errorMessage: "Invalid config; delayedUpload must be true/false"
    },
    useGlobalCache: {
      type: "boolean",
      errorMessage: "Invalid config; useGlobalCache must be true/false"
    },
    skipBuildCreation: {
      type: "boolean",
      errorMessage: "Invalid config; skipBuildCreation must be true/false"
    },
    tunnel: {
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: ["auto", "manual"],
          errorMessage: "Invalid config; tunnel type is mandatory parameter of type string having value auto or manual"
        },
        tunnelName: {
          type: "string",
          errorMessage: "Invalid config; tunnelName should be a string value"
        },
        user: {
          type: "string",
          errorMessage: "Invalid config; user should be a string value"
        },
        key: {
          type: "string",
          errorMessage: "Invalid config; key should be a string value"
        },
        port: {
          type: "string",
          errorMessage: "Invalid config; port should be a string value"
        },
        proxyHost: {
          type: "string",
          errorMessage: "Invalid config; proxyHost should be a string value"
        },
        proxyPort: {
          type: "number",
          errorMessage: "Invalid config; proxyPort should be an int value"
        },
        proxyUser: {
          type: "string",
          errorMessage: "Invalid config; proxyUser should be a string value"
        },
        proxyPass: {
          type: "string",
          errorMessage: "Invalid config; proxyPass should be a string value"
        },
        dir: {
          type: "string",
          errorMessage: "Invalid config; dir should be a string value"
        },
        v: {
          type: "boolean",
          errorMessage: "Invalid config; v should be a boolean value"
        },
        logFile: {
          type: "string",
          errorMessage: "Invalid config; logFile should be a string value"
        }
      },
      required: ["type"],
      additionalProperties: false
    },
    userAgent: {
      type: "string",
      errorMessage: "User Agent value must be a valid string"
    }
  },
  anyOf: [
    { required: ["web"] },
    { required: ["mobile"] }
  ],
  additionalProperties: false
};
var WebStaticConfigSchema = {
  type: "array",
  items: {
    type: "object",
    properties: {
      name: {
        type: "string",
        minLength: 1,
        errorMessage: "name is mandatory and cannot be empty"
      },
      url: {
        type: "string",
        format: "web-url",
        errorMessage: "url is mandatory and must be a valid web URL"
      },
      waitForTimeout: {
        type: "number",
        nullable: true,
        minimum: 0,
        maximum: 3e4,
        errorMessage: "waitForTimeout must be > 0 and <= 30000"
      },
      userAgent: {
        type: "string",
        errorMessage: "User Agent value must be a valid string"
      },
      execute: {
        type: "object",
        properties: {
          afterNavigation: {
            type: "string"
          },
          beforeSnapshot: {
            type: "string"
          }
        }
      },
      pageEvent: {
        type: "string",
        enum: ["load", "domcontentloaded"],
        errorMessage: "pageEvent can be load, domcontentloaded"
      }
    },
    required: ["name", "url"],
    additionalProperties: false
  },
  uniqueItems: true
};
var SnapshotSchema = {
  type: "object",
  properties: {
    name: {
      type: "string",
      minLength: 1,
      errorMessage: "Invalid snapshot; name is mandatory and cannot be empty"
    },
    url: {
      type: "string",
      format: "web-url",
      errorMessage: "Invalid snapshot; url is mandatory and must be a valid web URL"
    },
    dom: {
      type: "object"
    },
    options: {
      type: "object",
      properties: {
        element: {
          type: "object",
          properties: {
            id: {
              type: "string",
              pattern: "^[^;]*$",
              errorMessage: "Invalid snapshot options; element id cannot be empty or have semicolon"
            },
            class: {
              type: "string",
              pattern: "^[^;]*$",
              errorMessage: "Invalid snapshot options; element class cannot be empty or have semicolon"
            },
            cssSelector: {
              type: "string",
              pattern: "^[^;]*$",
              errorMessage: "Invalid snapshot options; element cssSelector cannot be empty or have semicolon"
            },
            xpath: {
              type: "string",
              errorMessage: "Invalid snapshot options; element xpath cannot be empty"
            }
          }
        },
        ignoreDOM: {
          type: "object",
          properties: {
            id: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; ignoreDOM id cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM id array must have unique items"
            },
            class: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; ignoreDOM class cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM class array must have unique items"
            },
            cssSelector: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; ignoreDOM cssSelector cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM cssSelector array must have unique items"
            },
            xpath: {
              type: "array",
              items: { type: "string", minLength: 1 },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM xpath array must have unique and non-empty items"
            }
          }
        },
        selectDOM: {
          type: "object",
          properties: {
            id: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; selectDOM id cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM id array must have unique items"
            },
            class: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; selectDOM class cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM class array must have unique items"
            },
            cssSelector: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; selectDOM cssSelector cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM cssSelector array must have unique items"
            },
            xpath: {
              type: "array",
              items: { type: "string", minLength: 1 },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM xpath array must have unique and non-empty items"
            }
          }
        },
        ignoreType: {
          type: "array",
          items: {
            type: "string",
            minLength: 1,
            enum: ["default", "layout", "images", "text", "colors", "dimensions", "position", "structure"],
            errorMessage: "Invalid snapshot options;ignoreType cannot be empty"
          },
          uniqueItems: true,
          errorMessage: "Invalid snapshot options; ignoreType must be an array of unique values from default, layout, images, text, colors, dimensions, position, structure"
        },
        web: {
          type: "object",
          properties: {
            browsers: {
              type: "array",
              items: {
                type: "string",
                enum: [constants_default.CHROME, constants_default.FIREFOX, constants_default.SAFARI, constants_default.EDGE],
                minLength: 1
              },
              uniqueItems: true,
              errorMessage: `Invalid snapshot options; allowed browsers - ${constants_default.CHROME}, ${constants_default.FIREFOX}, ${constants_default.SAFARI}, ${constants_default.EDGE}`
            },
            viewports: {
              type: "array",
              items: {
                type: "array",
                items: {
                  type: "number",
                  minimum: 1
                },
                minItems: 1,
                maxItems: 2,
                errorMessage: "Invalid snapshot options; each viewport array must contain either a single width or a width and height tuple with positive values."
              },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; viewports must be an array of unique arrays."
            }
          },
          required: ["viewports"],
          errorMessage: "Invalid snapshot options; web must include viewports property."
        },
        mobile: {
          type: "object",
          properties: {
            devices: {
              type: "array",
              items: {
                type: "string",
                enum: Object.keys(constants_default.SUPPORTED_MOBILE_DEVICES),
                minLength: 1
              },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; devices must be an array of unique supported mobile devices."
            },
            fullPage: {
              type: "boolean",
              errorMessage: "Invalid snapshot options; fullPage must be a boolean."
            },
            orientation: {
              type: "string",
              enum: [constants_default.MOBILE_ORIENTATION_PORTRAIT, constants_default.MOBILE_ORIENTATION_LANDSCAPE],
              errorMessage: "Invalid snapshot options; orientation must be either 'portrait' or 'landscape'."
            }
          },
          required: ["devices"],
          errorMessage: "Invalid snapshot options; mobile must include devices property."
        },
        loadDomContent: {
          type: "boolean",
          errorMessage: "Invalid snapshot options; loadDomContent must be a boolean"
        },
        sessionId: {
          type: "string",
          errorMessage: "Invalid snapshot options; sessionId must be a string"
        }
      },
      additionalProperties: false
    }
  },
  required: ["name", "url", "dom"],
  additionalProperties: false,
  errorMessage: "Invalid snapshot"
};
var FigmaDesignConfigSchema = {
  type: "object",
  properties: {
    depth: {
      type: "integer",
      minimum: 2,
      errorMessage: "Depth must be an integer and greater than 1"
    },
    figma_config: {
      type: "array",
      items: {
        type: "object",
        properties: {
          figma_file_token: {
            type: "string",
            minLength: 1,
            errorMessage: "figma_file_token is mandatory and cannot be empty"
          },
          figma_ids: {
            type: "array",
            items: {
              type: "string",
              minLength: 1,
              errorMessage: "Each ID in figma_ids must be a non-empty string"
            },
            minItems: 1,
            uniqueItems: true,
            errorMessage: {
              type: "figma_ids must be an array of strings",
              minItems: "figma_ids cannot be empty",
              uniqueItems: "figma_ids must contain unique values"
            }
          }
        },
        required: ["figma_file_token"],
        additionalProperties: false
      },
      uniqueItems: true,
      errorMessage: {
        uniqueItems: "Each entry in the Figma design configuration must be unique"
      }
    }
  },
  required: ["figma_config"],
  additionalProperties: false
};
var FigmaWebConfigSchema = {
  type: "object",
  "properties": {
    "web": {
      "type": "object",
      "properties": {
        browsers: {
          type: "array",
          items: { type: "string", enum: [constants_default.CHROME, constants_default.FIREFOX, constants_default.SAFARI, constants_default.EDGE] },
          uniqueItems: true,
          maxItems: 4,
          errorMessage: `allowed browsers - ${constants_default.CHROME}, ${constants_default.FIREFOX}, ${constants_default.SAFARI}, ${constants_default.EDGE}`
        },
        "viewports": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1
            },
            "minItems": 1
          }
        }
      },
      "required": ["browsers"]
    },
    "figma": {
      "type": "object",
      "properties": {
        depth: {
          type: "integer",
          minimum: 2,
          errorMessage: "Depth must be an integer and greater than 1"
        },
        "configs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "figma_file_token": {
                "type": "string",
                minLength: 1,
                errorMessage: "figma_file_token is mandatory and cannot be empty"
              },
              "figma_ids": {
                "type": "array",
                "items": {
                  "type": "string",
                  minLength: 1,
                  errorMessage: "Each ID in figma_ids must be a non-empty string"
                },
                minItems: 1,
                uniqueItems: true,
                errorMessage: {
                  type: "figma_ids must be an array of strings",
                  minItems: "figma_ids cannot be empty",
                  uniqueItems: "figma_ids must contain unique values"
                }
              },
              "screenshot_names": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                uniqueItems: false
              }
            },
            "required": ["figma_file_token", "figma_ids"]
          },
          uniqueItems: true,
          errorMessage: {
            uniqueItems: "Each entry in the figma configs must be unique"
          }
        }
      },
      "required": ["configs"]
    },
    smartIgnore: {
      type: "boolean",
      errorMessage: "Invalid config; smartIgnore must be true/false"
    }
  },
  "required": ["web", "figma"],
  additionalProperties: false
};
var FigmaAppConfigSchema = {
  type: "object",
  "properties": {
    "web": {
      "type": "object",
      "properties": {
        browsers: {
          type: "array",
          items: { type: "string", enum: [constants_default.CHROME, constants_default.FIREFOX, constants_default.SAFARI, constants_default.EDGE] },
          uniqueItems: true,
          maxItems: 4,
          errorMessage: `allowed browsers - ${constants_default.CHROME}, ${constants_default.FIREFOX}, ${constants_default.SAFARI}, ${constants_default.EDGE}`
        },
        "viewports": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1
            },
            "minItems": 1
          }
        }
      },
      "required": ["browsers"]
    },
    "mobile": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          name: {
            type: "string",
            minLength: 1,
            enum: Object.keys(constants_default.SUPPORTED_MOBILE_DEVICES),
            errorMessage: "unsupported mobile device name"
          },
          "platform": {
            "type": "array",
            "items": {
              "type": "string"
            },
            uniqueItems: true
          },
          orientation: {
            type: "string",
            enum: [constants_default.MOBILE_ORIENTATION_PORTRAIT, constants_default.MOBILE_ORIENTATION_LANDSCAPE],
            errorMessage: `Invalid config; orientation must be ${constants_default.MOBILE_ORIENTATION_PORTRAIT}/${constants_default.MOBILE_ORIENTATION_LANDSCAPE}`
          }
        },
        "required": ["name"]
      },
      uniqueItems: true
    },
    "figma": {
      "type": "object",
      "properties": {
        depth: {
          type: "integer",
          minimum: 2,
          errorMessage: "Depth must be an integer and greater than 1"
        },
        "configs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "figma_file_token": {
                "type": "string",
                minLength: 1,
                errorMessage: "figma_file_token is mandatory and cannot be empty"
              },
              "figma_ids": {
                "type": "array",
                "items": {
                  "type": "string",
                  minLength: 1,
                  errorMessage: "Each ID in figma_ids must be a non-empty string"
                },
                minItems: 1,
                uniqueItems: true,
                errorMessage: {
                  type: "figma_ids must be an array of strings",
                  minItems: "figma_ids cannot be empty",
                  uniqueItems: "figma_ids must contain unique values"
                }
              },
              "screenshot_names": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                uniqueItems: false
              }
            },
            "required": ["figma_file_token", "figma_ids"]
          },
          uniqueItems: true,
          errorMessage: {
            uniqueItems: "Each entry in the figma configs must be unique"
          }
        }
      },
      "required": ["configs"]
    },
    smartIgnore: {
      type: "boolean",
      errorMessage: "Invalid config; smartIgnore must be true/false"
    }
  },
  "required": ["mobile", "figma"],
  additionalProperties: false
};
var validateConfig = ajv.compile(ConfigSchema);
var validateWebStaticConfig = ajv.compile(WebStaticConfigSchema);
var validateSnapshot = ajv.compile(SnapshotSchema);
var validateFigmaDesignConfig = ajv.compile(FigmaDesignConfigSchema);
var validateWebFigmaConfig = ajv.compile(FigmaWebConfigSchema);
var validateAppFigmaConfig = ajv.compile(FigmaAppConfigSchema);
var lambdaTunnel = __require("@lambdatest/node-tunnel");
util.promisify(setTimeout);
var tunnelInstance;
function delDir(dir) {
  if (fs5__default.default.existsSync(dir)) {
    fs5__default.default.rmSync(dir, { recursive: true });
  }
}
function scrollToBottomAndBackToTop({
  frequency = 100,
  timing = 8,
  remoteWindow = window
} = {}) {
  return new Promise((resolve) => {
    let scrolls = 1;
    let scrollLength = remoteWindow.document.body.scrollHeight / frequency;
    (function scroll() {
      let scrollBy = scrollLength * scrolls;
      remoteWindow.setTimeout(() => {
        remoteWindow.scrollTo(0, scrollBy);
        if (scrolls < frequency) {
          scrolls += 1;
          scroll();
        }
        if (scrolls === frequency) {
          remoteWindow.setTimeout(() => {
            remoteWindow.scrollTo(0, 0);
            resolve();
          }, timing);
        }
      }, timing);
    })();
  });
}
function launchBrowsers(ctx) {
  return __async(this, null, function* () {
    var _a;
    let browsers = {};
    const isHeadless = ((_a = process.env.HEADLESS) == null ? void 0 : _a.toLowerCase()) === "false" ? false : true;
    let launchOptions = { headless: isHeadless };
    if (ctx.config.web) {
      for (const browser of ctx.config.web.browsers) {
        switch (browser) {
          case constants_default.CHROME:
            browsers[constants_default.CHROME] = yield test.chromium.launch(launchOptions);
            break;
          case constants_default.SAFARI:
            browsers[constants_default.SAFARI] = yield test.webkit.launch(launchOptions);
            break;
          case constants_default.FIREFOX:
            browsers[constants_default.FIREFOX] = yield test.firefox.launch(launchOptions);
            break;
          case constants_default.EDGE:
            launchOptions.args = ["--headless=new"];
            browsers[constants_default.EDGE] = yield test.chromium.launch(__spreadValues({ channel: constants_default.EDGE_CHANNEL }, launchOptions));
            break;
        }
      }
    }
    if (ctx.config.mobile) {
      for (const device of ctx.config.mobile.devices) {
        if (constants_default.SUPPORTED_MOBILE_DEVICES[device].os === "android" && !browsers[constants_default.CHROME])
          browsers[constants_default.CHROME] = yield test.chromium.launch(launchOptions);
        else if (constants_default.SUPPORTED_MOBILE_DEVICES[device].os === "ios" && !browsers[constants_default.SAFARI])
          browsers[constants_default.SAFARI] = yield test.webkit.launch(launchOptions);
      }
    }
    return browsers;
  });
}
function closeBrowsers(browsers) {
  return __async(this, null, function* () {
    var _a;
    for (const browserName of Object.keys(browsers))
      yield (_a = browsers[browserName]) == null ? void 0 : _a.close();
  });
}
function getWebRenderViewports(ctx) {
  let webRenderViewports = [];
  if (ctx.config.web) {
    for (const viewport of ctx.config.web.viewports) {
      webRenderViewports.push({
        viewport,
        viewportString: `${viewport.width}${viewport.height ? "x" + viewport.height : ""}`,
        fullPage: viewport.height ? false : true,
        device: false
      });
    }
  }
  return webRenderViewports;
}
function getWebRenderViewportsForOptions(options) {
  let webRenderViewports = [];
  if (options.web && Array.isArray(options.web.viewports)) {
    for (const viewport of options.web.viewports) {
      if (Array.isArray(viewport) && viewport.length > 0) {
        let viewportObj = {
          width: viewport[0]
        };
        if (viewport.length > 1) {
          viewportObj.height = viewport[1];
        }
        webRenderViewports.push({
          viewport: viewportObj,
          viewportString: `${viewport[0]}${viewport[1] ? "x" + viewport[1] : ""}`,
          fullPage: viewport.length === 1,
          device: false
        });
      }
    }
  }
  return webRenderViewports;
}
function getMobileRenderViewports(ctx) {
  var _a;
  let mobileRenderViewports = {};
  mobileRenderViewports[constants_default.MOBILE_OS_IOS] = [];
  mobileRenderViewports[constants_default.MOBILE_OS_ANDROID] = [];
  if (ctx.config.mobile) {
    for (const device of ctx.config.mobile.devices) {
      let os = constants_default.SUPPORTED_MOBILE_DEVICES[device].os;
      let { width, height } = constants_default.SUPPORTED_MOBILE_DEVICES[device].viewport;
      let portrait = ctx.config.mobile.orientation === constants_default.MOBILE_ORIENTATION_PORTRAIT ? true : false;
      (_a = mobileRenderViewports[os]) == null ? void 0 : _a.push({
        viewport: { width: portrait ? width : height, height: portrait ? height : width },
        viewportString: `${device} (${ctx.config.mobile.orientation})`,
        fullPage: ctx.config.mobile.fullPage,
        device: true,
        os
      });
    }
  }
  return mobileRenderViewports;
}
function getMobileRenderViewportsForOptions(options) {
  var _a;
  let mobileRenderViewports = {};
  mobileRenderViewports[constants_default.MOBILE_OS_IOS] = [];
  mobileRenderViewports[constants_default.MOBILE_OS_ANDROID] = [];
  if (options.mobile) {
    for (const device of options.mobile.devices) {
      let os = constants_default.SUPPORTED_MOBILE_DEVICES[device].os;
      let { width, height } = constants_default.SUPPORTED_MOBILE_DEVICES[device].viewport;
      let orientation = options.mobile.orientation || constants_default.MOBILE_ORIENTATION_PORTRAIT;
      let portrait = orientation === constants_default.MOBILE_ORIENTATION_PORTRAIT;
      let fullPage;
      if (options.mobile.fullPage === void 0 || options.mobile.fullPage) {
        fullPage = true;
      } else {
        fullPage = false;
      }
      (_a = mobileRenderViewports[os]) == null ? void 0 : _a.push({
        viewport: { width: portrait ? width : height, height: portrait ? height : width },
        viewportString: `${device} (${orientation})`,
        fullPage,
        device: true,
        os
      });
    }
  }
  return mobileRenderViewports;
}
function getRenderViewports(ctx) {
  let mobileRenderViewports = getMobileRenderViewports(ctx);
  let webRenderViewports = getWebRenderViewports(ctx);
  return [
    ...webRenderViewports,
    ...mobileRenderViewports[constants_default.MOBILE_OS_IOS],
    ...mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]
  ];
}
function getRenderViewportsForOptions(options) {
  let mobileRenderViewports = getMobileRenderViewportsForOptions(options);
  let webRenderViewports = getWebRenderViewportsForOptions(options);
  return [
    ...webRenderViewports,
    ...mobileRenderViewports[constants_default.MOBILE_OS_IOS],
    ...mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]
  ];
}
function startPolling(ctx, build_id, baseline, projectToken) {
  return __async(this, null, function* () {
    if (build_id) {
      ctx.log.info(`Fetching results for buildId ${build_id} in progress....`);
    } else if (ctx.build && ctx.build.id) {
      ctx.log.info(`Fetching results for buildId ${ctx.build.id} in progress....`);
    }
    const intervalId = setInterval(() => __async(this, null, function* () {
      try {
        let resp;
        if (build_id) {
          resp = yield ctx.client.getScreenshotData(build_id, baseline, ctx.log, projectToken);
        } else if (ctx.build && ctx.build.id) {
          resp = yield ctx.client.getScreenshotData(ctx.build.id, ctx.build.baseline, ctx.log, "");
        } else {
          return;
        }
        if (!resp.build) {
          ctx.log.info("Error: Build data is null.");
          clearInterval(intervalId);
          return;
        }
        let fileName = `${resp.build.build_id}.json`;
        if (ctx.options.fetchResults && ctx.options.fetchResultsFileName && ctx.build && ctx.build.id && resp.build.build_id === ctx.build.id) {
          fileName = `${ctx.options.fetchResultsFileName}`;
        }
        fs5__default.default.writeFileSync(`${fileName}`, JSON.stringify(resp, null, 2));
        ctx.log.debug(`Updated results in ${fileName}`);
        if (resp.build.build_status_ind === constants_default.BUILD_COMPLETE || resp.build.build_status_ind === constants_default.BUILD_ERROR) {
          clearInterval(intervalId);
          ctx.log.info(`Fetching results completed. Final results written to ${fileName}`);
          let totalScreenshotsWithMismatches = 0;
          let totalVariantsWithMismatches = 0;
          const totalScreenshots = Object.keys(resp.screenshots || {}).length;
          let totalVariants = 0;
          for (const [screenshot, variants] of Object.entries(resp.screenshots || {})) {
            let screenshotHasMismatch = false;
            let variantMismatchCount = 0;
            totalVariants += variants.length;
            for (const variant of variants) {
              if (variant.mismatch_percentage > 0) {
                screenshotHasMismatch = true;
                variantMismatchCount++;
              }
            }
            if (screenshotHasMismatch) {
              totalScreenshotsWithMismatches++;
              totalVariantsWithMismatches += variantMismatchCount;
            }
          }
          ctx.log.info(
            chalk__default.default.green.bold(
              `
Summary of Mismatches for buildId: ${build_id}
${chalk__default.default.yellow("Total Variants with Mismatches:")} ${chalk__default.default.white(totalVariantsWithMismatches)} out of ${chalk__default.default.white(totalVariants)}
${chalk__default.default.yellow("Total Screenshots with Mismatches:")} ${chalk__default.default.white(totalScreenshotsWithMismatches)} out of ${chalk__default.default.white(totalScreenshots)}
${chalk__default.default.yellow("Branch Name:")} ${chalk__default.default.white(resp.build.branch)}
${chalk__default.default.yellow("Project Name:")} ${chalk__default.default.white(resp.project.name)}
${chalk__default.default.yellow("Build ID:")} ${chalk__default.default.white(resp.build.build_id)}
`
            )
          );
        }
      } catch (error) {
        if (error.message.includes("ENOTFOUND")) {
          ctx.log.error("Error: Network error occurred while fetching build results. Please check your connection and try again.");
          clearInterval(intervalId);
        } else {
          ctx.log.error(`Error fetching screenshot data: ${error.message}`);
        }
        clearInterval(intervalId);
      }
    }), 5e3);
  });
}
var pingIntervalId = null;
function startPingPolling(ctx) {
  return __async(this, null, function* () {
    try {
      ctx.log.debug("Sending initial ping to server...");
      yield ctx.client.ping(ctx.build.id, ctx.log);
      ctx.log.debug("Initial ping sent successfully.");
    } catch (error) {
      ctx.log.error(`Error during initial ping: ${error.message}`);
    }
    pingIntervalId = setInterval(() => __async(this, null, function* () {
      try {
        ctx.log.debug("Sending ping to server...");
        yield ctx.client.ping(ctx.build.id, ctx.log);
        ctx.log.debug("Ping sent successfully.");
      } catch (error) {
        ctx.log.error(`Error during ping polling: ${error.message}`);
      }
    }), 10 * 60 * 1e3);
  });
}
function startTunnelBinary(ctx) {
  return __async(this, null, function* () {
    var _a;
    let tunnelConfig = ctx.config.tunnel;
    let tunnelArguments = {
      user: tunnelConfig.user || ctx.env.LT_USERNAME || "",
      key: tunnelConfig.key || ctx.env.LT_ACCESS_KEY || ""
    };
    ctx.config.tunnel.user = (tunnelConfig == null ? void 0 : tunnelConfig.user) || ctx.env.LT_USERNAME || "";
    ctx.config.tunnel.key = (tunnelConfig == null ? void 0 : tunnelConfig.key) || ctx.env.LT_ACCESS_KEY || "";
    if (tunnelConfig.port) {
      tunnelArguments.port = tunnelConfig.port;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.proxyHost) {
      tunnelArguments.proxyHost = tunnelConfig.proxyHost;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.proxyPort) {
      tunnelArguments.proxyPort = tunnelConfig.proxyPort;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.proxyUser) {
      tunnelArguments.proxyUser = tunnelConfig.proxyUser;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.proxyPass) {
      tunnelArguments.proxyPass = tunnelConfig.proxyPass;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.dir) {
      tunnelArguments.dir = tunnelConfig.dir;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.v) {
      tunnelArguments.v = tunnelConfig.v;
      tunnelArguments.logLevel = "debug";
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.logFile) {
      tunnelArguments.logFile = tunnelConfig.logFile;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.tunnelName) {
      tunnelArguments.tunnelName = tunnelConfig.tunnelName;
    } else {
      const randomNumber = Math.floor(1e6 + Math.random() * 9e6);
      let randomTunnelName = `smartui-cli-Node-tunnel-${randomNumber}`;
      tunnelArguments.tunnelName = randomTunnelName;
      ctx.config.tunnel.tunnelName = randomTunnelName;
    }
    ctx.log.debug(`tunnel config ${JSON.stringify(tunnelArguments)}`);
    if (((_a = ctx.config.tunnel) == null ? void 0 : _a.type) === "auto") {
      tunnelInstance = new lambdaTunnel();
      const istunnelStarted = yield tunnelInstance.start(tunnelArguments);
      ctx.log.debug("Tunnel is started Successfully with status " + istunnelStarted);
      const tunnelRunningStatus = yield tunnelInstance.isRunning();
      ctx.log.debug("Running status of tunnel after start ? " + tunnelRunningStatus);
    }
  });
}
function startPollingForTunnel(ctx, build_id, baseline, projectToken) {
  return __async(this, null, function* () {
    const intervalId = setInterval(() => __async(this, null, function* () {
      try {
        let resp;
        if (build_id) ; else if (ctx.build && ctx.build.id) {
          resp = yield ctx.client.getScreenshotData(ctx.build.id, ctx.build.baseline, ctx.log, "");
        } else {
          return;
        }
        if (!resp.build) {
          ctx.log.info("Error: Build data is null.");
          clearInterval(intervalId);
          const tunnelRunningStatus = yield tunnelInstance.isRunning();
          ctx.log.debug("Running status of tunnel before stopping ? " + tunnelRunningStatus);
          const status = yield tunnelInstance.stop();
          ctx.log.debug("Tunnel is Stopped ? " + status);
          return;
        }
        if (resp.build.build_status_ind === constants_default.BUILD_COMPLETE || resp.build.build_status_ind === constants_default.BUILD_ERROR) {
          clearInterval(intervalId);
          const tunnelRunningStatus = yield tunnelInstance.isRunning();
          ctx.log.debug("Running status of tunnel before stopping ? " + tunnelRunningStatus);
          const status = yield tunnelInstance.stop();
          ctx.log.debug("Tunnel is Stopped ? " + status);
        }
      } catch (error) {
        if (error.message.includes("ENOTFOUND")) {
          ctx.log.error("Error: Network error occurred while fetching build status while polling. Please check your connection and try again.");
          clearInterval(intervalId);
        } else {
          ctx.log.error(`Error fetching build status while polling: ${error.message}`);
        }
        clearInterval(intervalId);
      }
    }), 5e3);
  });
}
function stopTunnelHelper(ctx) {
  return __async(this, null, function* () {
    const tunnelRunningStatus = yield tunnelInstance.isRunning();
    ctx.log.debug("Running status of tunnel before stopping ? " + tunnelRunningStatus);
    const status = yield tunnelInstance.stop();
    ctx.log.debug("Tunnel is Stopped ? " + status);
  });
}

// src/lib/server.ts
var server_default = (ctx) => __async(void 0, null, function* () {
  const server = fastify__default.default({
    logger: {
      level: "debug",
      stream: { write: (message) => {
        ctx.log.debug(message);
      } }
    },
    bodyLimit: 3e7
  });
  const opts = {};
  const SMARTUI_DOM = fs5.readFileSync(path2__default.default.resolve(__dirname, "dom-serializer.js"), "utf-8");
  server.get("/healthcheck", opts, (_, reply) => {
    reply.code(200).send({ cliVersion: ctx.cliVersion });
  });
  server.get("/domserializer", opts, (request, reply) => {
    reply.code(200).send({ data: { dom: SMARTUI_DOM } });
  });
  server.post("/snapshot", opts, (request, reply) => __async(void 0, null, function* () {
    var _a, _b, _c;
    let replyCode;
    let replyBody;
    try {
      let { snapshot, testType } = request.body;
      if (!validateSnapshot(snapshot))
        throw new Error(validateSnapshot.errors[0].message);
      const sessionId = (_a = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _a.sessionId;
      let capsBuildId = "";
      if (sessionId) {
        if ((_b = ctx.sessionCapabilitiesMap) == null ? void 0 : _b.has(sessionId)) {
          const cachedCapabilities = ctx.sessionCapabilitiesMap.get(sessionId);
          capsBuildId = (cachedCapabilities == null ? void 0 : cachedCapabilities.buildId) || "";
        } else {
          try {
            let fetchedCapabilitiesResp = yield ctx.client.getSmartUICapabilities(sessionId, ctx.config, ctx.git, ctx.log);
            capsBuildId = (fetchedCapabilitiesResp == null ? void 0 : fetchedCapabilitiesResp.buildId) || "";
            ctx.log.debug(`fetch caps for sessionId: ${sessionId} are ${JSON.stringify(fetchedCapabilitiesResp)}`);
            if (capsBuildId) {
              ctx.sessionCapabilitiesMap.set(sessionId, fetchedCapabilitiesResp);
            } else if (fetchedCapabilitiesResp && (fetchedCapabilitiesResp == null ? void 0 : fetchedCapabilitiesResp.sessionId)) {
              ctx.sessionCapabilitiesMap.set(sessionId, fetchedCapabilitiesResp);
            }
          } catch (error) {
            ctx.log.debug(`Failed to fetch capabilities for sessionId ${sessionId}: ${error.message}`);
            console.log(`Failed to fetch capabilities for sessionId ${sessionId}: ${error.message}`);
          }
        }
      }
      ctx.testType = testType;
      (_c = ctx.snapshotQueue) == null ? void 0 : _c.enqueue(snapshot);
      ctx.isSnapshotCaptured = true;
      replyCode = 200;
      replyBody = { data: { message: "success", warnings: [] } };
    } catch (error) {
      ctx.log.debug(`snapshot failed; ${error}`);
      replyCode = 500;
      replyBody = { error: { message: error.message } };
    }
    return reply.code(replyCode).send(replyBody);
  }));
  server.post("/stop", opts, (_, reply) => __async(void 0, null, function* () {
    var _a, _b;
    let replyCode;
    let replyBody;
    try {
      if (ctx.config.delayedUpload) {
        ctx.log.debug("started after processing because of delayedUpload");
        (_a = ctx.snapshotQueue) == null ? void 0 : _a.startProcessingfunc();
      }
      yield new Promise((resolve) => {
        const intervalId = setInterval(() => {
          var _a2, _b2;
          if (((_a2 = ctx.snapshotQueue) == null ? void 0 : _a2.isEmpty()) && !((_b2 = ctx.snapshotQueue) == null ? void 0 : _b2.isProcessing())) {
            clearInterval(intervalId);
            resolve();
          }
        }, 1e3);
      });
      yield ctx.client.finalizeBuild(ctx.build.id, ctx.totalSnapshots, ctx.log);
      yield (_b = ctx.browser) == null ? void 0 : _b.close();
      if (ctx.server) {
        ctx.server.close();
      }
      let resp = yield ctx.client.getS3PreSignedURL(ctx);
      yield ctx.client.uploadLogs(ctx, resp.data.url);
      if (pingIntervalId !== null) {
        clearInterval(pingIntervalId);
        ctx.log.debug("Ping polling stopped immediately.");
      }
      replyCode = 200;
      replyBody = { data: { message: "success", type: "DELETE" } };
    } catch (error) {
      ctx.log.debug(error);
      ctx.log.debug(`stop endpoint failed; ${error}`);
      replyCode = 500;
      replyBody = { error: { message: error.message } };
    }
    return reply.code(replyCode).send(replyBody);
  }));
  server.get("/ping", opts, (_, reply) => {
    reply.code(200).send({ status: "Server is running", version: ctx.cliVersion });
  });
  yield server.listen({ port: ctx.options.port });
  let { port } = server.addresses()[0];
  process.env.SMARTUI_SERVER_ADDRESS = `http://localhost:${port}`;
  process.env.CYPRESS_SMARTUI_SERVER_ADDRESS = `http://localhost:${port}`;
  return server;
});

// src/lib/env.ts
var env_default = () => {
  const {
    PROJECT_TOKEN = "",
    SMARTUI_CLIENT_API_URL = "https://api.lambdatest.com/visualui/1.0",
    SMARTUI_GIT_INFO_FILEPATH,
    SMARTUI_DO_NOT_USE_CAPTURED_COOKIES,
    HTTP_PROXY,
    HTTPS_PROXY,
    SMARTUI_HTTP_PROXY,
    SMARTUI_HTTPS_PROXY,
    GITHUB_ACTIONS,
    FIGMA_TOKEN,
    LT_USERNAME,
    LT_ACCESS_KEY,
    LT_SDK_DEBUG,
    BASELINE_BRANCH,
    CURRENT_BRANCH,
    PROJECT_NAME,
    SMARTUI_API_PROXY,
    SMARTUI_API_SKIP_CERTIFICATES,
    USE_REMOTE_DISCOVERY,
    SMART_GIT
  } = process.env;
  return {
    PROJECT_TOKEN,
    SMARTUI_CLIENT_API_URL,
    SMARTUI_GIT_INFO_FILEPATH,
    HTTP_PROXY,
    HTTPS_PROXY,
    SMARTUI_HTTP_PROXY,
    SMARTUI_HTTPS_PROXY,
    GITHUB_ACTIONS,
    FIGMA_TOKEN,
    LT_USERNAME,
    LT_ACCESS_KEY,
    BASELINE_BRANCH,
    CURRENT_BRANCH,
    LT_SDK_DEBUG: LT_SDK_DEBUG === "true",
    SMARTUI_DO_NOT_USE_CAPTURED_COOKIES: SMARTUI_DO_NOT_USE_CAPTURED_COOKIES === "true",
    PROJECT_NAME,
    SMARTUI_API_PROXY,
    SMARTUI_API_SKIP_CERTIFICATES: SMARTUI_API_SKIP_CERTIFICATES === "true",
    USE_REMOTE_DISCOVERY: USE_REMOTE_DISCOVERY === "true",
    SMART_GIT: SMART_GIT === "true"
  };
};
var logContext = {};
function updateLogContext(newContext) {
  logContext = __spreadValues(__spreadValues({}, logContext), newContext);
}
var logLevel = () => {
  let env = env_default();
  return env.LT_SDK_DEBUG ? "debug" : "info";
};
var logger = winston.createLogger({
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf((info) => {
      let contextString = Object.values(logContext).join(" | ");
      let message = typeof info.message === "object" ? JSON.stringify(info.message).trim() : info.message.trim();
      switch (info.level) {
        case "warn":
          message = chalk__default.default.yellow(message);
          break;
        case "error":
          message = chalk__default.default.red(message);
          break;
      }
      return info.level === "info" ? message : `[${contextString}:${info.level}] ` + message;
    })
  ),
  transports: [
    new winston.transports.Console({
      level: logLevel()
    }),
    new winston.transports.File({
      level: "debug",
      filename: constants_default.LOG_FILE_PATH
    })
  ]
});
var logger_default = logger;

// src/tasks/startServer.ts
var startServer_default = (ctx) => {
  return {
    title: `Setting up SmartUI server`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      var _a;
      updateLogContext({ task: "startServer" });
      try {
        ctx2.server = yield server_default(ctx2);
        task.output = chalk__default.default.gray(`listening on port ${(_a = ctx2.server.addresses()[0]) == null ? void 0 : _a.port}`);
        task.title = "SmartUI started";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("SmartUI server setup failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var authExec_default = (ctx) => {
  return {
    title: `Authenticating with SmartUI`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "auth" });
      try {
        if (!ctx2.env.PROJECT_NAME && !ctx2.env.PROJECT_TOKEN) {
          ctx2.authenticatedInitially = false;
          task.output = chalk__default.default.gray(`Empty PROJECT_TOKEN and PROJECT_NAME. Skipping authentication. Expecting SmartUI Capabilities in driver!`);
          task.title = "Skipped Authentication with SmartUI";
        } else {
          const { authResult, orgId, userId } = yield ctx2.client.authExec(ctx2, ctx2.log, ctx2.env);
          if (authResult === 2) {
            task.output = chalk__default.default.gray(`New project '${ctx2.env.PROJECT_NAME}' created successfully`);
          } else if (authResult === 0) {
            task.output = chalk__default.default.gray(`Using existing project token '******#${ctx2.env.PROJECT_TOKEN.split("#").pop()}'`);
          } else if (authResult === 1) {
            task.output = chalk__default.default.gray(`Using existing project '${ctx2.env.PROJECT_NAME}'`);
          }
          ctx2.orgId = orgId;
          ctx2.userId = userId;
          ctx2.authenticatedInitially = true;
          task.title = "Authenticated with SmartUI";
        }
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Authentication failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};

// package.json
var version = "4.1.12";
var package_default = {
  name: "@lambdatest/smartui-cli",
  version,
  description: "A command line interface (CLI) to run SmartUI tests on LambdaTest",
  files: [
    "dist/**/*"
  ],
  scripts: {
    build: "tsup",
    release: "pnpm run build && pnpm publish --access public --no-git-checks",
    "release:beta": "pnpm run build && pnpm publish --tag beta --access public --no-git-checks",
    "local-build": "pnpm run build && pnpm pack"
  },
  bin: {
    smartui: "./dist/index.cjs"
  },
  type: "module",
  keywords: [
    "lambdatest",
    "smartui",
    "cli"
  ],
  author: "LambdaTest <keys@lambdatest.com>",
  license: "MIT",
  dependencies: {
    "@playwright/browser-chromium": "^1.47.2",
    "@playwright/browser-firefox": "^1.47.2",
    "@playwright/browser-webkit": "^1.47.2",
    "@playwright/test": "^1.47.2",
    "@types/cross-spawn": "^6.0.4",
    "@types/node": "^20.8.9",
    "@types/which": "^3.0.2",
    "@lambdatest/node-tunnel": "^4.0.9",
    ajv: "^8.12.0",
    "ajv-errors": "^3.0.0",
    axios: "^1.6.0",
    chalk: "^4.1.2",
    commander: "^11.1.0",
    "cross-spawn": "^7.0.3",
    fastify: "^4.24.3",
    "form-data": "^4.0.0",
    listr2: "^7.0.1",
    "node-cache": "^5.1.2",
    sharp: "^0.33.4",
    tsup: "^7.2.0",
    uuid: "^11.0.3",
    which: "^4.0.0",
    winston: "^3.10.0"
  },
  devDependencies: {
    typescript: "^5.3.2"
  }
};
var httpClient = class {
  constructor({ SMARTUI_CLIENT_API_URL, PROJECT_TOKEN, PROJECT_NAME, LT_USERNAME, LT_ACCESS_KEY, SMARTUI_API_PROXY, SMARTUI_API_SKIP_CERTIFICATES }) {
    this.projectToken = PROJECT_TOKEN || "";
    this.projectName = PROJECT_NAME || "";
    this.username = LT_USERNAME || "";
    this.accessKey = LT_ACCESS_KEY || "";
    let proxyUrl = null;
    try {
      const urlStr = (SMARTUI_API_PROXY == null ? void 0 : SMARTUI_API_PROXY.startsWith("http")) ? SMARTUI_API_PROXY : `http://${SMARTUI_API_PROXY}`;
      proxyUrl = SMARTUI_API_PROXY ? new URL(urlStr) : null;
    } catch (error) {
      console.error("Invalid proxy URL:", error);
    }
    const axiosConfig = {
      baseURL: SMARTUI_CLIENT_API_URL,
      proxy: proxyUrl ? {
        host: proxyUrl.hostname,
        port: proxyUrl.port ? Number(proxyUrl.port) : 80
      } : false
    };
    if (SMARTUI_API_SKIP_CERTIFICATES) {
      axiosConfig.httpsAgent = new https__default.default.Agent({
        rejectUnauthorized: false
      });
    }
    this.axiosInstance = axios__default.default.create(axiosConfig);
    this.axiosInstance.interceptors.request.use((config) => {
      if (!config.headers["projectToken"] && this.projectToken !== "") {
        config.headers["projectToken"] = this.projectToken;
      } else if (!config.headers["projectName"] && this.projectName !== "") {
        config.headers["projectName"] = this.projectName;
        if (!config.headers["username"] || config.headers["username"] === "") {
          config.headers["username"] = this.username;
        }
        if (!config.headers["accessKey"] || config.headers["accessKey"] === "") {
          config.headers["accessKey"] = this.accessKey;
        }
      }
      return config;
    });
    this.axiosInstance.interceptors.response.use(
      (response) => response,
      (error) => __async(this, null, function* () {
        const { config } = error;
        if (config && config.url === "/screenshot" && config.method === "post") {
          if (!config.retryCount) {
            config.retryCount = 0;
            config.retry = 2;
            config.retryDelay = 5e3;
          }
          if (config.retryCount < config.retry) {
            config.retryCount += 1;
            yield new Promise((resolve) => setTimeout(resolve, config.retryDelay));
            config.timeout = 3e4;
            return this.axiosInstance(config);
          }
          return Promise.reject(error);
        }
      })
    );
  }
  request(config, log2) {
    return __async(this, null, function* () {
      log2.debug(`http request: ${config.method} ${config.url}`);
      if (config && config.data && !config.data.name && !config.data.snapshot) {
        log2.debug(config.data);
      }
      if (config && config.data && config.data.snapshotUuid) {
        log2.debug(config.data);
      }
      return this.axiosInstance.request(config).then((resp) => {
        if (resp) {
          log2.debug(`http response: ${JSON.stringify({
            status: resp.status,
            headers: resp.headers,
            body: resp.data
          })}`);
          if (resp.data !== "") {
            return resp.data;
          } else {
            return resp;
          }
        } else {
          log2.debug(`empty response: ${JSON.stringify(resp)}`);
          return {};
        }
      }).catch((error) => {
        var _a;
        if (error.response) {
          log2.debug(`http response: ${JSON.stringify({
            status: error.response.status,
            headers: error.response.headers,
            body: error.response.data
          })}`);
          throw new Error(((_a = error.response.data.error) == null ? void 0 : _a.message) || error.response.data.message || error.response.data);
        }
        if (error.request) {
          log2.debug(`http request failed: ${error.toJSON()}`);
          throw new Error(error.toJSON().message);
        }
        log2.debug(`http request failed: ${error.message}`);
        throw new Error(error.message);
      });
    });
  }
  auth(log2, env) {
    return __async(this, null, function* () {
      let result = 1;
      if (this.projectToken) {
        result = 0;
      }
      const response = yield this.request({
        url: "/token/verify",
        method: "GET"
      }, log2);
      if (response && response.projectToken) {
        this.projectToken = response.projectToken;
        env.PROJECT_TOKEN = response.projectToken;
        if (response.message && response.message.includes("Project created successfully")) {
          result = 2;
        }
        return result;
      } else {
        throw new Error("Authentication failed, project token not received");
      }
    });
  }
  authExec(ctx, log2, env) {
    return __async(this, null, function* () {
      var _a, _b;
      let authResult = 1;
      let userName = "";
      let passWord = "";
      if (ctx.config.tunnel) {
        if (((_a = ctx.config.tunnel) == null ? void 0 : _a.user) && ((_b = ctx.config.tunnel) == null ? void 0 : _b.key)) {
          userName = ctx.config.tunnel.user;
          passWord = ctx.config.tunnel.key;
        } else {
          userName = this.username;
          passWord = this.accessKey;
        }
      }
      if (this.projectToken) {
        authResult = 0;
      }
      const response = yield this.request({
        url: "/token/verify",
        method: "GET",
        headers: {
          username: userName,
          accessKey: passWord
        }
      }, log2);
      if (response && response.projectToken) {
        let orgId = 0;
        let userId = 0;
        this.projectToken = response.projectToken;
        env.PROJECT_TOKEN = response.projectToken;
        if (response.message && response.message.includes("Project created successfully")) {
          authResult = 2;
        }
        if (response.orgId) {
          orgId = response.orgId;
        }
        if (response.userId) {
          userId = response.userId;
        }
        return { authResult, orgId, userId };
      } else {
        if (response && response.message) {
          throw new Error(response.message);
        }
        throw new Error("Authentication failed, project token not received. Refer to the smartui.log file for more information");
      }
    });
  }
  createBuild(git, config, log2, buildName, isStartExec, smartGit, markBaseline, baselineBuild) {
    return this.request({
      url: "/build",
      method: "POST",
      data: {
        git,
        config,
        buildName,
        isStartExec,
        packageVersion: package_default.version,
        smartGit,
        markBaseline,
        baselineBuild
      }
    }, log2);
  }
  getScreenshotData(buildId, baseline, log2, projectToken) {
    return this.request({
      url: "/screenshot",
      method: "GET",
      params: { buildId, baseline },
      headers: { projectToken }
    }, log2);
  }
  getTunnelDetails(ctx, log2) {
    var _a, _b, _c;
    const data = {
      orgId: ctx.orgId,
      userId: ctx.userId,
      userName: (_a = ctx.config.tunnel) == null ? void 0 : _a.user,
      password: (_b = ctx.config.tunnel) == null ? void 0 : _b.key
    };
    if ((_c = ctx.config.tunnel) == null ? void 0 : _c.tunnelName) {
      data.tunnelName = ctx.config.tunnel.tunnelName;
    }
    return this.request({
      url: "/tunnel",
      method: "POST",
      data
    }, log2);
  }
  ping(buildId, log2) {
    return this.request({
      url: "/build/ping",
      method: "POST",
      data: {
        buildId
      }
    }, log2);
  }
  getSmartUICapabilities(sessionId, config, git, log2) {
    return this.request({
      url: "/sessions/capabilities",
      method: "GET",
      params: {
        sessionId
      },
      data: {
        git,
        config
      },
      headers: {
        projectToken: "",
        projectName: "",
        username: "",
        accessKey: ""
      }
    }, log2);
  }
  finalizeBuild(buildId, totalSnapshots, log2) {
    let params = { buildId };
    if (totalSnapshots > -1)
      params.totalSnapshots = totalSnapshots;
    return this.request({
      url: "/build",
      method: "DELETE",
      params
    }, log2);
  }
  finalizeBuildForCapsWithToken(buildId, totalSnapshots, projectToken, log2) {
    let params = { buildId };
    if (totalSnapshots > -1)
      params.totalSnapshots = totalSnapshots;
    return this.request({
      url: "/build",
      method: "DELETE",
      params,
      headers: {
        projectToken
        // Use projectToken dynamically
      }
    }, log2);
  }
  uploadSnapshot(ctx, snapshot, discoveryErrors) {
    return this.request({
      url: `/builds/${ctx.build.id}/snapshot`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: {
        snapshot,
        test: {
          type: ctx.testType,
          source: "cli"
        },
        discoveryErrors
      }
    }, ctx.log);
  }
  processSnapshot(ctx, snapshot, snapshotUuid, discoveryErrors) {
    return this.request({
      url: `/build/${ctx.build.id}/snapshot`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: {
        name: snapshot.name,
        url: snapshot.url,
        snapshotUuid,
        test: {
          type: ctx.testType,
          source: "cli"
        },
        doRemoteDiscovery: snapshot.options.doRemoteDiscovery,
        discoveryErrors
      }
    }, ctx.log);
  }
  processSnapshotCaps(ctx, snapshot, snapshotUuid, capsBuildId, capsProjectToken, discoveryErrors) {
    return this.request({
      url: `/build/${capsBuildId}/snapshot`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        projectToken: capsProjectToken !== "" ? capsProjectToken : this.projectToken
      },
      data: {
        name: snapshot.name,
        url: snapshot.url,
        snapshotUuid,
        test: {
          type: ctx.testType,
          source: "cli"
        },
        doRemoteDiscovery: snapshot.options.doRemoteDiscovery,
        discoveryErrors
      }
    }, ctx.log);
  }
  uploadSnapshotForCaps(ctx, snapshot, capsBuildId, capsProjectToken, discoveryErrors) {
    const buildId = capsBuildId !== "" ? capsBuildId : ctx.build.id;
    return this.request({
      url: `/builds/${buildId}/snapshot`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        projectToken: capsProjectToken !== "" ? capsProjectToken : this.projectToken
        // Use capsProjectToken dynamically
      },
      data: {
        snapshot,
        test: {
          type: ctx.testType,
          source: "cli"
        },
        discoveryErrors
      }
    }, ctx.log);
  }
  uploadScreenshot({ id: buildId, name: buildName, baseline }, ssPath, ssName, browserName, viewport, log2) {
    browserName = browserName === constants_default.SAFARI ? constants_default.WEBKIT : browserName;
    const file = fs5__default.default.readFileSync(ssPath);
    const form = new FormData__default.default();
    form.append("screenshot", file, { filename: `${ssName}.png`, contentType: "image/png" });
    form.append("browser", browserName);
    form.append("viewport", viewport);
    form.append("buildId", buildId);
    form.append("buildName", buildName);
    form.append("screenshotName", ssName);
    form.append("baseline", baseline.toString());
    return this.axiosInstance.request({
      url: `/screenshot`,
      method: "POST",
      headers: form.getHeaders(),
      data: form,
      timeout: 3e4
    }).then(() => {
      log2.debug(`${ssName} for ${browserName} ${viewport} uploaded successfully`);
    }).catch((error) => {
      log2.error(`Unable to upload screenshot ${JSON.stringify(error)}`);
      if (error && error.response && error.response.data && error.response.data.error) {
        throw new Error(error.response.data.error.message);
      }
      if (error) {
        throw new Error(JSON.stringify(error));
      }
    });
  }
  checkUpdate(log2) {
    return this.request({
      url: `/packageinfo`,
      method: "GET",
      headers: { "Content-Type": "application/json" },
      params: {
        packageName: package_default.name,
        packageVersion: package_default.version
      }
    }, log2);
  }
  getFigmaFilesAndImages(figmaFileToken, figmaToken, queryParams, authToken, depth, markBaseline, buildName, log2) {
    const requestBody = {
      figma_file_token: figmaFileToken,
      figma_token: figmaToken,
      query_params: queryParams,
      auth: authToken,
      depth,
      mark_base_line: markBaseline,
      build_name: buildName
    };
    return this.request({
      url: "/uploadfigma",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      data: JSON.stringify(requestBody)
    }, log2);
  }
  getS3PreSignedURL(ctx) {
    return this.request({
      url: `/loguploadurl`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: {
        buildId: ctx.build.id
      }
    }, ctx.log);
  }
  getS3PresignedURLForSnapshotUpload(ctx, snapshotName, snapshotUuid) {
    return this.request({
      url: `/snapshotuploadurl`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: {
        buildId: ctx.build.id,
        snapshotName,
        snapshotUuid
      }
    }, ctx.log);
  }
  getS3PresignedURLForSnapshotUploadCaps(ctx, snapshotName, snapshotUuid, capsBuildId, capsProjectToken) {
    return this.request({
      url: `/snapshotuploadurl`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        projectToken: capsProjectToken !== "" ? capsProjectToken : this.projectToken
      },
      data: {
        buildId: capsBuildId,
        snapshotName,
        snapshotUuid
      }
    }, ctx.log);
  }
  uploadLogs(ctx, uploadURL) {
    const fileStream = fs5__default.default.createReadStream(constants_default.LOG_FILE_PATH);
    const { size } = fs5__default.default.statSync(constants_default.LOG_FILE_PATH);
    return this.request({
      url: uploadURL,
      method: "PUT",
      headers: {
        "Content-Type": "text/plain",
        "Content-Length": size
      },
      data: fileStream,
      maxBodyLength: Infinity,
      // prevent axios from limiting the body size
      maxContentLength: Infinity
      // prevent axios from limiting the content size
    }, ctx.log);
  }
  uploadSnapshotToS3(ctx, uploadURL, snapshot) {
    return this.request({
      url: uploadURL,
      method: "PUT",
      headers: {
        "Content-Type": "application/json"
      },
      data: snapshot,
      maxBodyLength: Infinity,
      // prevent axios from limiting the body size
      maxContentLength: Infinity
      // prevent axios from limiting the content size
    }, ctx.log);
  }
  uploadSnapshotToS3Caps(ctx, uploadURL, snapshot, capsProjectToken) {
    return this.request({
      url: uploadURL,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        projectToken: capsProjectToken !== "" ? capsProjectToken : this.projectToken
      },
      data: snapshot,
      maxBodyLength: Infinity,
      // prevent axios from limiting the body size
      maxContentLength: Infinity
      // prevent axios from limiting the content size
    }, ctx.log);
  }
  processWebFigma(requestBody, log2) {
    requestBody.packageVersion = package_default.version;
    return this.request({
      url: "figma-web/upload",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      data: JSON.stringify(requestBody)
    }, log2);
  }
  fetchWebFigma(buildId, log2) {
    return this.request({
      url: "figma-web/fetch",
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      },
      params: { buildId }
    }, log2);
  }
  fetchBuildInfo(requestData, ctx) {
    return this.request({
      url: `/fetchBuildInfo`,
      method: "GET",
      data: requestData
    }, ctx.log);
  }
  mergeBuildsByBuildId(requestData, ctx) {
    return this.request({
      url: `/mergeBuilds`,
      method: "POST",
      data: requestData
    }, ctx.log);
  }
};
var ctx_default = (options) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  let env = env_default();
  let webConfig;
  let mobileConfig;
  let basicAuthObj;
  let tunnelObj;
  let config = constants_default.DEFAULT_CONFIG;
  let port;
  let resolutionOff;
  let extensionFiles;
  let ignoreStripExtension;
  let ignoreFilePattern;
  let parallelObj;
  let fetchResultObj;
  let fetchResultsFileObj;
  let buildNameObj;
  try {
    if (options.config) {
      config = JSON.parse(fs5__default.default.readFileSync(options.config, "utf-8"));
      logger_default.debug(`Config file ${options.config} loaded: ${JSON.stringify(config, null, 2)}`);
      if ((_a = config.web) == null ? void 0 : _a.resolutions) {
        config.web.viewports = config.web.resolutions;
        delete config.web.resolutions;
      }
      if (!validateConfig(config)) {
        throw new Error(validateConfig.errors[0].message);
      }
    } else {
      logger_default.info("## No config file provided. Using default config.");
    }
    port = parseInt(options.port || "49152", 10);
    if (isNaN(port) || port < 1 || port > 65535) {
      throw new Error("Invalid port number. Port number must be an integer between 1 and 65535.");
    }
    resolutionOff = options.ignoreResolutions || false;
    extensionFiles = options.files || ["png", "jpeg", "jpg"];
    ignoreStripExtension = options.removeExtensions || false;
    ignoreFilePattern = options.ignoreDir || [];
    parallelObj = options.parallel ? options.parallel === true ? 1 : options.parallel : 1;
    if (options.fetchResults) {
      if (options.fetchResults !== true && !options.fetchResults.endsWith(".json")) {
        console.error("Error: The file extension for --fetch-results must be .json");
        process.exit(1);
      }
      fetchResultObj = true;
      fetchResultsFileObj = options.fetchResults === true ? "" : options.fetchResults;
    } else {
      fetchResultObj = false;
      fetchResultsFileObj = "";
    }
    buildNameObj = options.buildName || "";
    if (options.userName && options.accessKey) {
      env.LT_USERNAME = options.userName;
      env.LT_ACCESS_KEY = options.accessKey;
    }
  } catch (error) {
    console.log(`[smartui] Error: ${error.message}`);
    process.exit();
  }
  if (config.web) {
    webConfig = { browsers: config.web.browsers, viewports: [] };
    for (let viewport of (_b = config.web) == null ? void 0 : _b.viewports)
      webConfig.viewports.push({ width: viewport[0], height: viewport[1] || 0 });
  }
  if (config.mobile) {
    mobileConfig = {
      devices: config.mobile.devices,
      fullPage: (_c = config.mobile.fullPage) != null ? _c : true,
      orientation: config.mobile.orientation || constants_default.MOBILE_ORIENTATION_PORTRAIT
    };
  }
  if (config.basicAuthorization) {
    basicAuthObj = config.basicAuthorization;
  }
  if (config.tunnel) {
    tunnelObj = config.tunnel;
  }
  return {
    env,
    log: logger_default,
    client: new httpClient(env),
    config: {
      web: webConfig,
      mobile: mobileConfig,
      waitForPageRender: config.waitForPageRender || 0,
      waitForTimeout: config.waitForTimeout || 0,
      waitForDiscovery: config.waitForDiscovery || 3e4,
      enableJavaScript: (_d = config.enableJavaScript) != null ? _d : false,
      cliEnableJavaScript: (_e = config.cliEnableJavaScript) != null ? _e : true,
      scrollTime: config.scrollTime || constants_default.DEFAULT_SCROLL_TIME,
      allowedHostnames: config.allowedHostnames || [],
      allowedAssets: config.allowedAssets || [],
      basicAuthorization: basicAuthObj,
      smartIgnore: (_f = config.smartIgnore) != null ? _f : false,
      delayedUpload: (_g = config.delayedUpload) != null ? _g : false,
      useGlobalCache: (_h = config.useGlobalCache) != null ? _h : false,
      ignoreHTTPSErrors: (_i = config.ignoreHTTPSErrors) != null ? _i : false,
      skipBuildCreation: (_j = config.skipBuildCreation) != null ? _j : false,
      tunnel: tunnelObj,
      userAgent: config.userAgent || ""
    },
    uploadFilePath: "",
    webStaticConfig: [],
    git: {
      branch: "",
      commitId: "",
      commitAuthor: "",
      commitMessage: "",
      githubURL: ""
    },
    build: {
      id: "",
      name: buildNameObj,
      baseline: false,
      url: ""
    },
    args: {},
    tunnelDetails: {
      tunnelPort: -1,
      tunnelHost: "",
      tunnelName: ""
    },
    options: {
      parallel: parallelObj,
      force: options.force ? true : false,
      markBaseline: options.markBaseline ? true : false,
      buildName: options.buildName || "",
      port,
      ignoreResolutions: resolutionOff,
      fileExtension: extensionFiles,
      stripExtension: ignoreStripExtension,
      ignorePattern: ignoreFilePattern,
      fetchResults: fetchResultObj,
      fetchResultsFileName: fetchResultsFileObj,
      baselineBranch: options.baselineBranch || "",
      baselineBuild: options.baselineBuild || ""
    },
    cliVersion: version,
    totalSnapshots: -1,
    isStartExec: false,
    isSnapshotCaptured: false,
    sessionCapabilitiesMap: /* @__PURE__ */ new Map(),
    buildToSnapshotCountMap: /* @__PURE__ */ new Map(),
    fetchResultsForBuild: new Array(),
    orgId: 0,
    userId: 0,
    mergeBranchSource: "",
    mergeBranchTarget: "",
    mergeBuildSource: "",
    mergeBuildTarget: "",
    mergeBuildSourceId: "",
    mergeBuildTargetId: "",
    mergeByBranch: false,
    mergeByBuild: false
  };
};
function executeCommand(command9) {
  let dst = process.cwd();
  try {
    return child_process.execSync(command9, {
      cwd: dst,
      stdio: ["ignore"],
      encoding: "utf-8"
    });
  } catch (error) {
    throw new Error(error.message);
  }
}
function isGitRepo() {
  try {
    executeCommand("git status");
    return true;
  } catch (error) {
    return false;
  }
}
var git_default = (ctx) => {
  if (ctx.env.SMART_GIT) {
    ctx.env.BASELINE_BRANCH = "";
    if (ctx.options.baselineBranch !== "") {
      ctx.env.SMART_GIT = false;
    }
  }
  if (ctx.env.SMARTUI_GIT_INFO_FILEPATH) {
    let gitInfo = JSON.parse(fs5__default.default.readFileSync(ctx.env.SMARTUI_GIT_INFO_FILEPATH, "utf-8"));
    if (ctx.options.markBaseline) {
      ctx.env.BASELINE_BRANCH = ctx.env.CURRENT_BRANCH || gitInfo.branch || "";
      ctx.env.SMART_GIT = false;
    }
    return {
      branch: ctx.env.CURRENT_BRANCH || gitInfo.branch || "",
      commitId: gitInfo.commit_id.slice(0, 6) || "",
      commitMessage: gitInfo.commit_body || "",
      commitAuthor: gitInfo.commit_author || "",
      githubURL: ctx.env.GITHUB_ACTIONS ? `${constants_default.GITHUB_API_HOST}/repos/${process.env.GITHUB_REPOSITORY}/statuses/${gitInfo.commit_id}` : "",
      baselineBranch: ctx.options.baselineBranch || ctx.env.BASELINE_BRANCH || ""
    };
  } else {
    const splitCharacter = "<##>";
    const prettyFormat = ["%h", "%H", "%s", "%f", "%b", "%at", "%ct", "%an", "%ae", "%cn", "%ce", "%N", ""];
    const command9 = 'git log -1 --pretty=format:"' + prettyFormat.join(splitCharacter) + '" && git rev-parse --abbrev-ref HEAD && git tag --contains HEAD';
    let res = executeCommand(command9).split(splitCharacter);
    var branchAndTags = res[res.length - 1].split("\n").filter((n) => n);
    var branch = ctx.env.CURRENT_BRANCH || branchAndTags[0];
    branchAndTags.slice(1);
    if (ctx.options.markBaseline) {
      ctx.env.BASELINE_BRANCH = branch || "";
      ctx.env.SMART_GIT = false;
    }
    return {
      branch: branch || "",
      commitId: res[0] || "",
      commitMessage: res[2] || "",
      commitAuthor: res[7] || "",
      githubURL: ctx.env.GITHUB_ACTIONS ? `${constants_default.GITHUB_API_HOST}/repos/${process.env.GITHUB_REPOSITORY}/statuses/${res[1]}` : "",
      baselineBranch: ctx.options.baselineBranch || ctx.env.BASELINE_BRANCH || ""
    };
  }
};
var getGitInfo_default = (ctx) => {
  return {
    title: `Fetching git repo details`,
    skip: (ctx2) => {
      return !isGitRepo() && !ctx2.env.SMARTUI_GIT_INFO_FILEPATH ? "[SKIPPED] Fetching git repo details; not a git repo" : "";
    },
    task: (ctx2, task) => __async(void 0, null, function* () {
      if (ctx2.env.CURRENT_BRANCH && ctx2.env.CURRENT_BRANCH.trim() === "") {
        throw new Error("Error: The environment variable CURRENT_BRANCH cannot be empty.");
      }
      try {
        ctx2.git = git_default(ctx2);
        task.output = chalk__default.default.gray(`branch: ${ctx2.git.branch}, commit: ${ctx2.git.commitId}, author: ${ctx2.git.commitAuthor}`);
        task.title = "Fetched git information";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(`${error.message}`);
        throw new Error("Error fetching git repo details");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var createBuildExec_default = (ctx) => {
  return {
    title: `Creating SmartUI build`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      var _a, _b, _c;
      updateLogContext({ task: "createBuild" });
      try {
        if (ctx2.authenticatedInitially && !ctx2.config.skipBuildCreation) {
          let resp = yield ctx2.client.createBuild(ctx2.git, ctx2.config, ctx2.log, ctx2.build.name, ctx2.isStartExec, ctx2.env.SMART_GIT, ctx2.options.markBaseline, ctx2.options.baselineBuild);
          if (resp && resp.data && resp.data.buildId) {
            ctx2.build = {
              id: resp.data.buildId,
              name: resp.data.buildName,
              url: resp.data.buildURL,
              baseline: resp.data.baseline,
              useKafkaFlow: resp.data.useKafkaFlow || false
            };
          } else if (resp && resp.error) {
            if (resp.error.message) {
              ctx2.log.error(`Error while creation of build: ${resp.error.message}`);
              throw new Error(`Error while creation of build: ${resp.error.message}`);
            }
          }
          if (ctx2.build.id === "") {
            ctx2.log.debug("Build creation failed: Build ID is empty");
            task.output = chalk__default.default.red("Build creation failed: Build ID is empty");
            throw new Error("SmartUI build creation failed");
          }
          task.output = chalk__default.default.gray(`build id: ${resp.data.buildId}`);
          task.title = "SmartUI build created";
        } else {
          task.output = chalk__default.default.gray(`Empty PROJECT_TOKEN and PROJECT_NAME. Skipping Creation of Build!`);
          task.title = "Skipped SmartUI build creation";
          if (ctx2.config.tunnel && ((_a = ctx2.config.tunnel) == null ? void 0 : _a.type) === "auto") {
            yield stopTunnelHelper(ctx2);
          }
        }
        if (ctx2.config.tunnel && ((_b = ctx2.config.tunnel) == null ? void 0 : _b.type) === "auto") {
          if (ctx2.build && ctx2.build.id) {
            startPollingForTunnel(ctx2, "", false, "");
          }
        }
        if (ctx2.config.tunnel) {
          let tunnelResp = yield ctx2.client.getTunnelDetails(ctx2, ctx2.log);
          ctx2.log.debug(`Tunnel Response: ${JSON.stringify(tunnelResp)}`);
          if (tunnelResp && tunnelResp.data && tunnelResp.data.host && tunnelResp.data.port && tunnelResp.data.tunnel_name) {
            ctx2.tunnelDetails = {
              tunnelHost: tunnelResp.data.host,
              tunnelPort: tunnelResp.data.port,
              tunnelName: tunnelResp.data.tunnel_name
            };
            ctx2.log.debug(`Tunnel Details: ${JSON.stringify(ctx2.tunnelDetails)}`);
          } else if (tunnelResp && tunnelResp.error) {
            if (tunnelResp.error.message) {
              if (tunnelResp.error.code && tunnelResp.error.code === 400) {
                ctx2.log.warn(tunnelResp.error.message);
              } else {
                ctx2.log.warn(`Error while fetch tunnel details; Either tunnel is not running or tunnel parameters are different`);
              }
            }
          }
        }
      } catch (error) {
        ctx2.log.debug(error);
        if (ctx2.config.tunnel && ((_c = ctx2.config.tunnel) == null ? void 0 : _c.type) === "auto") {
          yield stopTunnelHelper(ctx2);
        }
        task.output = chalk__default.default.gray(error.message);
        throw new Error("SmartUI build creation failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var exec_default = (ctx) => {
  var _a;
  return {
    title: `Executing '${(_a = ctx.args.execCommand) == null ? void 0 : _a.join(" ")}'`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      if (ctx2.options.fetchResults) {
        if (ctx2.build && ctx2.build.id) {
          startPolling(ctx2, "", false, "");
        }
      }
      updateLogContext({ task: "exec" });
      return new Promise((resolve, reject) => {
        var _a2, _b, _c;
        const childProcess = spawn__default.default(ctx2.args.execCommand[0], (_a2 = ctx2.args.execCommand) == null ? void 0 : _a2.slice(1));
        let totalOutput = "";
        const output = listr2.createWritable((chunk) => {
          totalOutput += chunk;
          task.output = chalk__default.default.gray(totalOutput);
        });
        (_b = childProcess.stdout) == null ? void 0 : _b.pipe(output);
        (_c = childProcess.stderr) == null ? void 0 : _c.pipe(output);
        childProcess.on("error", (error) => {
          var _a3;
          task.output = chalk__default.default.gray(`error: ${error.message}`);
          throw new Error(`Execution of '${(_a3 = ctx2.args.execCommand) == null ? void 0 : _a3.join(" ")}' failed`);
        });
        childProcess.on("close", (code, signal) => __async(void 0, null, function* () {
          var _a3;
          if (code !== null) {
            task.title = `Execution of '${(_a3 = ctx2.args.execCommand) == null ? void 0 : _a3.join(" ")}' completed; exited with code ${code}`;
          } else if (signal !== null) {
            throw new Error(`Child process killed with signal ${signal}`);
          }
          resolve();
        }));
      });
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};
var processSnapshot_default = (ctx) => {
  return {
    title: `Processing snapshots`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      var _a, _b;
      try {
        if (ctx2.config.delayedUpload) {
          ctx2.log.debug("started after processing because of delayedUpload");
          (_a = ctx2.snapshotQueue) == null ? void 0 : _a.startProcessingfunc();
        }
        yield new Promise((resolve) => {
          let output2 = "";
          const intervalId = setInterval(() => {
            var _a2, _b2, _c;
            if (((_a2 = ctx2.snapshotQueue) == null ? void 0 : _a2.isEmpty()) && !((_b2 = ctx2.snapshotQueue) == null ? void 0 : _b2.isProcessing())) {
              clearInterval(intervalId);
              resolve();
            } else {
              task.title = `Processing snapshot ${(_c = ctx2.snapshotQueue) == null ? void 0 : _c.getProcessingSnapshot()}`;
            }
          }, 500);
        });
        let output = "";
        for (let snapshot of (_b = ctx2.snapshotQueue) == null ? void 0 : _b.getProcessedSnapshots()) {
          if (snapshot.error)
            output += `${chalk__default.default.red("\u2717")} ${chalk__default.default.gray(`${snapshot.name}
[error] ${snapshot.error}`)}
`;
          else
            output += `${chalk__default.default.green("\u2713")} ${chalk__default.default.gray(snapshot.name)}
${snapshot.warnings.length ? chalk__default.default.gray(`[warning] ${snapshot.warnings.join("\n[warning] ")}
`) : ""}`;
        }
        task.output = output;
        task.title = "Processed snapshots";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Processing of snapshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var finalizeBuild_default = (ctx) => {
  return {
    title: `Finalizing build`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      var _a, _b;
      updateLogContext({ task: "finalizeBuild" });
      try {
        if (ctx2.build.id) {
          yield ctx2.client.finalizeBuild(ctx2.build.id, ctx2.totalSnapshots, ctx2.log);
        }
        if (ctx2.build.hasDiscoveryError) {
          ctx2.log.warn(`We found some network errors while capturing DOM snapshots. These network errors may cause visual differences in your screenshots. Please go to ${ctx2.build.url} for more details`);
        }
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Finalize build failed");
      }
      let buildUrls = `build url: ${ctx2.build.url}
`;
      for (const [sessionId, capabilities] of ctx2.sessionCapabilitiesMap.entries()) {
        try {
          const buildId = (capabilities == null ? void 0 : capabilities.buildId) || "";
          const projectToken = (capabilities == null ? void 0 : capabilities.projectToken) || "";
          const totalSnapshots = (capabilities == null ? void 0 : capabilities.snapshotCount) || 0;
          const sessionBuildUrl = (capabilities == null ? void 0 : capabilities.buildURL) || "";
          const testId = (capabilities == null ? void 0 : capabilities.id) || "";
          if (ctx2.options.fetchResults && ctx2.fetchResultsForBuild) {
            if (!ctx2.fetchResultsForBuild.includes(buildId)) {
              let is_baseline;
              if (capabilities.baseline) {
                is_baseline = true;
              } else {
                is_baseline = false;
              }
              console.log(`start polling was called at finalize build for buildId: ${buildId}`);
              startPolling(ctx2, buildId, is_baseline, capabilities.projectToken);
              yield new Promise((resolve) => setTimeout(resolve, 7e3));
              ctx2.fetchResultsForBuild.push(buildId);
            }
          }
          if (buildId && projectToken) {
            yield ctx2.client.finalizeBuildForCapsWithToken(buildId, totalSnapshots, projectToken, ctx2.log);
          }
          if (testId && buildId) {
            buildUrls += `TestId ${testId}: ${sessionBuildUrl}
`;
          }
        } catch (error) {
          ctx2.log.debug(`Error finalizing build for session ${sessionId}: ${error.message}`);
        }
      }
      task.output = chalk__default.default.gray(buildUrls);
      task.title = "Finalized build";
      try {
        yield (_a = ctx2.browser) == null ? void 0 : _a.close();
        ctx2.log.debug(`Closed browser`);
        yield (_b = ctx2.server) == null ? void 0 : _b.close();
        ctx2.log.debug(`Closed server`);
        if (ctx2.isSnapshotCaptured) {
          ctx2.log.debug(`Log file to be uploaded`);
          let resp = yield ctx2.client.getS3PreSignedURL(ctx2);
          yield ctx2.client.uploadLogs(ctx2, resp.data.url);
        }
      } catch (error) {
        ctx2.log.debug(error);
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var globalCache = new NodeCache__default.default({ stdTTL: 3600, checkperiod: 600 });
var MAX_RESOURCE_SIZE = 15 * 1024 ** 2;
var ALLOWED_RESOURCES = ["document", "stylesheet", "image", "media", "font", "other"];
var ALLOWED_STATUSES = [200, 201];
var REQUEST_TIMEOUT = 18e5;
var MIN_VIEWPORT_HEIGHT = 1080;
function prepareSnapshot(snapshot, ctx) {
  return __async(this, null, function* () {
    let processedOptions = {};
    processedOptions.cliEnableJavascript = ctx.config.cliEnableJavaScript;
    processedOptions.ignoreHTTPSErrors = ctx.config.ignoreHTTPSErrors;
    if (ctx.config.basicAuthorization) {
      processedOptions.basicAuthorization = ctx.config.basicAuthorization;
    }
    ctx.config.allowedHostnames.push(new URL(snapshot.url).hostname);
    processedOptions.allowedHostnames = ctx.config.allowedHostnames;
    processedOptions.skipCapturedCookies = ctx.env.SMARTUI_DO_NOT_USE_CAPTURED_COOKIES;
    if (ctx.env.HTTP_PROXY || ctx.env.HTTPS_PROXY)
      processedOptions.proxy = { server: ctx.env.HTTP_PROXY || ctx.env.HTTPS_PROXY };
    if (ctx.env.SMARTUI_HTTP_PROXY || ctx.env.SMARTUI_HTTPS_PROXY)
      processedOptions.proxy = { server: ctx.env.SMARTUI_HTTP_PROXY || ctx.env.SMARTUI_HTTPS_PROXY };
    let options = snapshot.options;
    let optionWarnings = /* @__PURE__ */ new Set();
    let selectors = [];
    let ignoreOrSelectDOM;
    if (options && Object.keys(options).length) {
      ctx.log.debug(`Snapshot options: ${JSON.stringify(options)}`);
      const isNotAllEmpty = (obj) => {
        var _a;
        for (let key in obj)
          if ((_a = obj[key]) == null ? void 0 : _a.length)
            return true;
        return false;
      };
      if (options.loadDomContent) {
        processedOptions.loadDomContent = true;
      }
      if (options.sessionId) {
        const sessionId = options.sessionId;
        processedOptions.sessionId = sessionId;
        if (ctx.sessionCapabilitiesMap && ctx.sessionCapabilitiesMap.has(sessionId)) {
          const sessionCapabilities = ctx.sessionCapabilitiesMap.get(sessionId);
          if (sessionCapabilities && sessionCapabilities.id) {
            processedOptions.testId = sessionCapabilities.id;
          }
        }
      }
      if (options.web && Object.keys(options.web).length) {
        processedOptions.web = {};
        if (options.web.viewports && options.web.viewports.length > 0) {
          processedOptions.web.viewports = options.web.viewports.filter(
            (viewport) => Array.isArray(viewport) && viewport.length > 0
          );
        }
        if (options.web.browsers && options.web.browsers.length > 0) {
          processedOptions.web.browsers = options.web.browsers;
        }
      }
      if (options.mobile && Object.keys(options.mobile).length) {
        processedOptions.mobile = {};
        if (options.mobile.devices && options.mobile.devices.length > 0) {
          processedOptions.mobile.devices = options.mobile.devices;
        }
        if (options.mobile.hasOwnProperty("fullPage") && typeof options.mobile.fullPage === "boolean") {
          processedOptions.mobile.fullPage = options.mobile.fullPage;
        } else {
          processedOptions.mobile.fullPage = true;
        }
        if (options.mobile.hasOwnProperty("orientation") && (options.mobile.orientation === constants_default.MOBILE_ORIENTATION_PORTRAIT || options.mobile.orientation === constants_default.MOBILE_ORIENTATION_LANDSCAPE)) {
          processedOptions.mobile.orientation = options.mobile.orientation;
        } else {
          processedOptions.mobile.orientation = constants_default.MOBILE_ORIENTATION_PORTRAIT;
        }
      }
      if (options.element && Object.keys(options.element).length) {
        if (options.element.id)
          processedOptions.element = "#" + options.element.id;
        else if (options.element.class)
          processedOptions.element = "." + options.element.class;
        else if (options.element.cssSelector)
          processedOptions.element = options.element.cssSelector;
        else if (options.element.xpath)
          processedOptions.element = "xpath=" + options.element.xpath;
      } else if (options.ignoreDOM && Object.keys(options.ignoreDOM).length && isNotAllEmpty(options.ignoreDOM)) {
        processedOptions.ignoreBoxes = {};
        ignoreOrSelectDOM = "ignoreDOM";
      } else if (options.selectDOM && Object.keys(options.selectDOM).length && isNotAllEmpty(options.selectDOM)) {
        processedOptions.selectBoxes = {};
        ignoreOrSelectDOM = "selectDOM";
      }
      if (ignoreOrSelectDOM) {
        for (const [key, value] of Object.entries(options[ignoreOrSelectDOM])) {
          switch (key) {
            case "id":
              selectors.push(...value.map((e) => "#" + e));
              break;
            case "class":
              selectors.push(...value.map((e) => "." + e));
              break;
            case "xpath":
              selectors.push(...value.map((e) => "xpath=" + e));
              break;
            case "cssSelector":
              selectors.push(...value);
              break;
          }
        }
      }
      if (options.ignoreType) {
        processedOptions.ignoreType = options.ignoreType;
      }
    }
    if (ctx.config.tunnel) {
      if (ctx.tunnelDetails && ctx.tunnelDetails.tunnelPort != -1 && ctx.tunnelDetails.tunnelHost != "") {
        const tunnelAddress = `http://${ctx.tunnelDetails.tunnelHost}:${ctx.tunnelDetails.tunnelPort}`;
        processedOptions.tunnelAddress = tunnelAddress;
        ctx.log.debug(`Tunnel address added to processedOptions: ${tunnelAddress}`);
      }
    }
    processedOptions.allowedAssets = ctx.config.allowedAssets;
    processedOptions.selectors = selectors;
    processedOptions.ignoreDOM = options == null ? void 0 : options.ignoreDOM;
    processedOptions.selectDOM = options == null ? void 0 : options.selectDOM;
    ctx.log.debug(`Processed options: ${JSON.stringify(processedOptions)}`);
    let renderViewports;
    if (snapshot.options && snapshot.options.web || snapshot.options && snapshot.options.mobile) {
      renderViewports = getRenderViewportsForOptions(snapshot.options);
    } else {
      renderViewports = getRenderViewports(ctx);
    }
    processedOptions.doRemoteDiscovery = true;
    return {
      processedSnapshot: {
        name: snapshot.name,
        url: snapshot.url,
        dom: Buffer.from(snapshot.dom.html).toString("base64"),
        resources: {},
        options: processedOptions,
        cookies: Buffer.from(snapshot.dom.cookies).toString("base64"),
        renderViewports
      },
      warnings: [...optionWarnings, ...snapshot.dom.warnings]
    };
  });
}
function processSnapshot(snapshot, ctx) {
  return __async(this, null, function* () {
    var _a, _b;
    updateLogContext({ task: "discovery" });
    ctx.log.debug(`Processing snapshot ${snapshot.name} ${snapshot.url}`);
    const isHeadless = ((_a = process.env.HEADLESS) == null ? void 0 : _a.toLowerCase()) === "false" ? false : true;
    let discoveryErrors = {
      name: "",
      url: "",
      timestamp: "",
      snapshotUUID: "",
      browsers: {}
    };
    let processedOptions = {};
    let globalViewport = "";
    let globalBrowser = constants_default.CHROME;
    let launchOptions = {
      headless: isHeadless,
      args: constants_default.LAUNCH_ARGS
    };
    let contextOptions = {
      javaScriptEnabled: ctx.config.cliEnableJavaScript,
      userAgent: constants_default.CHROME_USER_AGENT,
      ignoreHTTPSErrors: ctx.config.ignoreHTTPSErrors
    };
    if (!((_b = ctx.browser) == null ? void 0 : _b.isConnected())) {
      if (ctx.env.HTTP_PROXY || ctx.env.HTTPS_PROXY)
        launchOptions.proxy = { server: ctx.env.HTTP_PROXY || ctx.env.HTTPS_PROXY };
      if (ctx.env.SMARTUI_HTTP_PROXY || ctx.env.SMARTUI_HTTPS_PROXY)
        launchOptions.proxy = { server: ctx.env.SMARTUI_HTTP_PROXY || ctx.env.SMARTUI_HTTPS_PROXY };
      ctx.browser = yield test.chromium.launch(launchOptions);
      ctx.log.debug(`Chromium launched with options ${JSON.stringify(launchOptions)}`);
    }
    const context = yield ctx.browser.newContext(contextOptions);
    ctx.log.debug(`Browser context created with options ${JSON.stringify(contextOptions)}`);
    if (!ctx.env.SMARTUI_DO_NOT_USE_CAPTURED_COOKIES && snapshot.dom.cookies) {
      const domainName = new URL(snapshot.url).hostname;
      ctx.log.debug(`Setting cookies for domain: ${domainName}`);
      const cookieArray = snapshot.dom.cookies.split("; ").map((cookie) => {
        if (!cookie)
          return null;
        const [name, value] = cookie.split("=");
        if (!name || !value)
          return null;
        return {
          name: name.trim(),
          value: value.trim(),
          domain: domainName,
          path: "/"
        };
      }).filter(Boolean);
      if (cookieArray.length > 0) {
        yield context.addCookies(cookieArray);
      } else {
        ctx.log.debug("No valid cookies to add");
      }
    }
    const page = yield context.newPage();
    let cache = {};
    if (snapshot.dom.resources.length) {
      for (let resource of snapshot.dom.resources) {
        let body = resource.mimetype == "text/css" ? Buffer.from(resource.content).toString("base64") : resource.content;
        cache[resource.url] = {
          body,
          type: resource.mimetype
        };
      }
    }
    yield page.route("**/*", (route, request) => __async(this, null, function* () {
      var _a2;
      const requestUrl = request.url();
      const requestHostname = new URL(requestUrl).hostname;
      let requestOptions = {
        timeout: REQUEST_TIMEOUT,
        headers: __spreadValues(__spreadValues({}, yield request.allHeaders()), constants_default.REQUEST_HEADERS)
      };
      try {
        if (/\.(mp3|mp4|wav|ogg|webm)$/i.test(request.url())) {
          throw new Error("resource type mp3/mp4/wav/ogg/webm");
        }
        ctx.config.allowedHostnames.push(new URL(snapshot.url).hostname);
        if (ctx.config.enableJavaScript)
          ALLOWED_RESOURCES.push("script");
        if (ctx.config.basicAuthorization) {
          ctx.log.debug(`Adding basic authorization to the headers for root url`);
          let token = Buffer.from(`${ctx.config.basicAuthorization.username}:${ctx.config.basicAuthorization.password}`).toString("base64");
          requestOptions.headers.Authorization = `Basic ${token}`;
        }
        let response, body;
        if (requestUrl === snapshot.url) {
          response = {
            status: () => 200,
            headers: () => ({ "content-type": "text/html" })
          };
          body = snapshot.dom.html;
        } else if (cache[requestUrl]) {
          response = {
            status: () => 200,
            headers: () => ({ "content-type": cache[requestUrl].mimetype })
          };
          body = cache[requestUrl].body;
        } else if (ctx.config.useGlobalCache && globalCache.has(requestUrl)) {
          ctx.log.debug(`Found resource ${requestUrl} in global cache`);
          response = {
            status: () => 200,
            headers: () => ({ "content-type": globalCache.get(requestUrl).type })
          };
          body = globalCache.get(requestUrl).body;
        } else {
          ctx.log.debug(`Resource not found in cache or global cache ${requestUrl} fetching from server`);
          response = yield page.request.fetch(request, requestOptions);
          body = yield response.body();
        }
        if (!body) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping no response`);
        } else if (!body.length) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping empty response`);
        } else if (requestUrl === snapshot.url) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping root resource`);
        } else if (!ctx.config.allowedHostnames.includes(requestHostname)) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping remote resource`);
        } else if (cache[requestUrl]) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping already cached resource`);
        } else if (body.length > MAX_RESOURCE_SIZE) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping resource larger than 15MB`);
        } else if (!ALLOWED_RESOURCES.includes(request.resourceType())) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping disallowed resource type [${request.resourceType()}]`);
        } else if (!ALLOWED_STATUSES.includes(response.status())) {
          ctx.log.debug(`${globalViewport} Handling request ${requestUrl}
 - skipping disallowed status [${response.status()}]`);
          if (response && response.headers()) {
            const responseHeaders = response.headers();
            ctx.log.debug(`Response headers for ${requestUrl}: ${JSON.stringify(responseHeaders, null, 2)}`);
          }
          let responseOfRetry, bodyOfRetry;
          ctx.log.debug(`Resource had a disallowed status ${requestUrl} fetching from server again`);
          responseOfRetry = yield page.request.fetch(request, requestOptions);
          bodyOfRetry = yield responseOfRetry.body();
          if (responseOfRetry && responseOfRetry.status() && ALLOWED_STATUSES.includes(responseOfRetry.status())) {
            ctx.log.debug(`Handling request after retry ${requestUrl}
 - content-type ${responseOfRetry.headers()["content-type"]}`);
            cache[requestUrl] = {
              body: bodyOfRetry.toString("base64"),
              type: responseOfRetry.headers()["content-type"]
            };
            route.fulfill({
              status: responseOfRetry.status(),
              headers: responseOfRetry.headers(),
              body: bodyOfRetry
            });
          } else {
            ctx.log.debug(`Resource had a disallowed status for retry as well  ${requestUrl} disallowed status [${responseOfRetry.status()}]`);
            if (responseOfRetry && responseOfRetry.headers()) {
              const responseHeadersRetry = responseOfRetry.headers();
              ctx.log.debug(`Response headers for retry ${requestUrl}: ${JSON.stringify(responseHeadersRetry, null, 2)}`);
            }
            let data = {
              statusCode: `${responseOfRetry.status()}`,
              url: requestUrl,
              resourceType: request.resourceType()
            };
            if (!discoveryErrors.browsers[globalBrowser]) {
              discoveryErrors.browsers[globalBrowser] = {};
            }
            if (discoveryErrors.browsers[globalBrowser] && !discoveryErrors.browsers[globalBrowser][globalViewport]) {
              discoveryErrors.browsers[globalBrowser][globalViewport] = [];
            }
            if (discoveryErrors.browsers[globalBrowser]) {
              (_a2 = discoveryErrors.browsers[globalBrowser][globalViewport]) == null ? void 0 : _a2.push(data);
            }
          }
        } else {
          ctx.log.debug(`Handling request ${requestUrl}
 - content-type ${response.headers()["content-type"]}`);
          if (ctx.config.useGlobalCache) {
            globalCache.set(requestUrl, {
              body: body.toString("base64"),
              type: response.headers()["content-type"]
            });
          }
          cache[requestUrl] = {
            body: body.toString("base64"),
            type: response.headers()["content-type"]
          };
        }
        route.fulfill({
          status: response.status(),
          headers: response.headers(),
          body
        });
      } catch (error) {
        ctx.log.debug(`Handling request ${requestUrl}
 - aborted due to ${error.message}`);
        route.abort();
      }
    }));
    let options = snapshot.options;
    let optionWarnings = /* @__PURE__ */ new Set();
    let selectors = [];
    let ignoreOrSelectDOM;
    let ignoreOrSelectBoxes;
    if (options && Object.keys(options).length) {
      ctx.log.debug(`Snapshot options: ${JSON.stringify(options)}`);
      const isNotAllEmpty = (obj) => {
        var _a2;
        for (let key in obj)
          if ((_a2 = obj[key]) == null ? void 0 : _a2.length)
            return true;
        return false;
      };
      if (options.loadDomContent) {
        processedOptions.loadDomContent = true;
      }
      if (options.sessionId) {
        const sessionId = options.sessionId;
        processedOptions.sessionId = sessionId;
        if (ctx.sessionCapabilitiesMap && ctx.sessionCapabilitiesMap.has(sessionId)) {
          const sessionCapabilities = ctx.sessionCapabilitiesMap.get(sessionId);
          if (sessionCapabilities && sessionCapabilities.id) {
            processedOptions.testId = sessionCapabilities.id;
          }
        }
      }
      if (options.web && Object.keys(options.web).length) {
        processedOptions.web = {};
        if (options.web.viewports && options.web.viewports.length > 0) {
          processedOptions.web.viewports = options.web.viewports.filter(
            (viewport) => Array.isArray(viewport) && viewport.length > 0
          );
        }
        if (options.web.browsers && options.web.browsers.length > 0) {
          processedOptions.web.browsers = options.web.browsers;
        }
      }
      if (options.mobile && Object.keys(options.mobile).length) {
        processedOptions.mobile = {};
        if (options.mobile.devices && options.mobile.devices.length > 0) {
          processedOptions.mobile.devices = options.mobile.devices;
        }
        if (options.mobile.hasOwnProperty("fullPage") && typeof options.mobile.fullPage === "boolean") {
          processedOptions.mobile.fullPage = options.mobile.fullPage;
        } else {
          processedOptions.mobile.fullPage = true;
        }
        if (options.mobile.hasOwnProperty("orientation") && (options.mobile.orientation === constants_default.MOBILE_ORIENTATION_PORTRAIT || options.mobile.orientation === constants_default.MOBILE_ORIENTATION_LANDSCAPE)) {
          processedOptions.mobile.orientation = options.mobile.orientation;
        } else {
          processedOptions.mobile.orientation = constants_default.MOBILE_ORIENTATION_PORTRAIT;
        }
      }
      if (options.element && Object.keys(options.element).length) {
        if (options.element.id)
          processedOptions.element = "#" + options.element.id;
        else if (options.element.class)
          processedOptions.element = "." + options.element.class;
        else if (options.element.cssSelector)
          processedOptions.element = options.element.cssSelector;
        else if (options.element.xpath)
          processedOptions.element = "xpath=" + options.element.xpath;
      } else if (options.ignoreDOM && Object.keys(options.ignoreDOM).length && isNotAllEmpty(options.ignoreDOM)) {
        processedOptions.ignoreBoxes = {};
        ignoreOrSelectDOM = "ignoreDOM";
        ignoreOrSelectBoxes = "ignoreBoxes";
      } else if (options.selectDOM && Object.keys(options.selectDOM).length && isNotAllEmpty(options.selectDOM)) {
        processedOptions.selectBoxes = {};
        ignoreOrSelectDOM = "selectDOM";
        ignoreOrSelectBoxes = "selectBoxes";
      }
      if (ignoreOrSelectDOM) {
        for (const [key, value] of Object.entries(options[ignoreOrSelectDOM])) {
          switch (key) {
            case "id":
              selectors.push(...value.map((e) => "#" + e));
              break;
            case "class":
              selectors.push(...value.map((e) => "." + e));
              break;
            case "xpath":
              selectors.push(...value.map((e) => "xpath=" + e));
              break;
            case "cssSelector":
              selectors.push(...value);
              break;
          }
        }
      }
      if (options.ignoreType) {
        processedOptions.ignoreType = options.ignoreType;
      }
    }
    if (ctx.config.tunnel) {
      if (ctx.tunnelDetails && ctx.tunnelDetails.tunnelPort != -1 && ctx.tunnelDetails.tunnelHost != "") {
        const tunnelAddress = `http://${ctx.tunnelDetails.tunnelHost}:${ctx.tunnelDetails.tunnelPort}`;
        processedOptions.tunnelAddress = tunnelAddress;
        ctx.log.debug(`Tunnel address added to processedOptions: ${tunnelAddress}`);
      }
    }
    let navigated = false;
    let previousDeviceType = null;
    let renderViewports;
    if (snapshot.options && snapshot.options.web || snapshot.options && snapshot.options.mobile) {
      renderViewports = getRenderViewportsForOptions(snapshot.options);
    } else {
      renderViewports = getRenderViewports(ctx);
    }
    for (const { viewport, viewportString, fullPage, device } of renderViewports) {
      if (previousDeviceType !== null && previousDeviceType !== device) {
        navigated = false;
      }
      previousDeviceType = device;
      yield page.setViewportSize({ width: viewport.width, height: viewport.height || MIN_VIEWPORT_HEIGHT });
      ctx.log.debug(`Page resized to ${viewport.width}x${viewport.height || MIN_VIEWPORT_HEIGHT}`);
      globalViewport = viewportString;
      ctx.log.debug(`globalViewport : ${globalViewport}`);
      if (globalViewport.toLowerCase().includes("iphone") || globalViewport.toLowerCase().includes("ipad")) {
        globalBrowser = constants_default.WEBKIT;
      } else {
        globalBrowser = constants_default.CHROME;
      }
      if (!navigated) {
        try {
          discoveryErrors.url = snapshot.url;
          discoveryErrors.name = snapshot.name;
          yield page.goto(snapshot.url, { waitUntil: "domcontentloaded", timeout: ctx.config.waitForDiscovery });
          yield new Promise((r) => setTimeout(r, 1250));
          if (ctx.config.waitForTimeout)
            yield page.waitForTimeout(ctx.config.waitForTimeout);
          navigated = true;
          ctx.log.debug(`Navigated to ${snapshot.url}`);
        } catch (error) {
          ctx.log.debug(`Navigation to discovery page failed; ${error}`);
          if (error && error.name && error.name === "TimeoutError") {
            ctx.log.debug(`Payload uploaded tough navigation to discovery page failed; ${error}`);
            return {
              processedSnapshot: {
                name: snapshot.name,
                url: snapshot.url,
                dom: Buffer.from(snapshot.dom.html).toString("base64"),
                resources: cache,
                options: processedOptions
              },
              warnings: [...optionWarnings, ...snapshot.dom.warnings]
            };
          }
        }
      }
      if (ctx.config.cliEnableJavaScript && fullPage)
        yield page.evaluate(scrollToBottomAndBackToTop, { frequency: 100, timing: ctx.config.scrollTime });
      try {
        yield page.waitForLoadState("networkidle", { timeout: 5e3 });
        ctx.log.debug("Network idle 500ms");
      } catch (error) {
        ctx.log.debug(`Network idle failed due to ${error}`);
      }
      if (ctx.config.allowedAssets && ctx.config.allowedAssets.length) {
        for (let assetUrl of ctx.config.allowedAssets) {
          if (!cache[assetUrl]) {
            ctx.log.debug(`Fetching asset ${assetUrl} from allowedAssets array`);
            try {
              const response = yield page.request.fetch(assetUrl, {
                timeout: 25e3,
                headers: __spreadValues({}, constants_default.REQUEST_HEADERS)
              });
              const body = yield response.body();
              if (body && body.length) {
                ctx.log.debug(`Caching asset ${assetUrl}`);
                cache[assetUrl] = {
                  body: body.toString("base64"),
                  type: response.headers()["content-type"]
                };
              } else {
                ctx.log.debug(`Asset ${assetUrl} returned empty or invalid body`);
              }
            } catch (error) {
              if (error && error.message) {
                ctx.log.debug(`Error fetching asset with error message ${assetUrl}: ${error.message}`);
              }
              ctx.log.debug(`Error fetching asset ${assetUrl}: ${JSON.stringify(error)}`);
            }
          } else {
            ctx.log.debug(`Asset ${assetUrl} already cached`);
          }
        }
      }
      if (processedOptions.element) {
        let l = yield page.locator(processedOptions.element).all();
        if (l.length === 0) {
          throw new Error(`for snapshot ${snapshot.name} viewport ${viewportString}, no element found for selector ${processedOptions.element}`);
        } else if (l.length > 1) {
          throw new Error(`for snapshot ${snapshot.name} viewport ${viewportString}, multiple elements found for selector ${processedOptions.element}`);
        }
      } else if (selectors.length) {
        let height = 0;
        height = yield page.evaluate(() => {
          const DEFAULT_HEIGHT = 16384;
          const body = document.body;
          const html = document.documentElement;
          if (!body || !html) {
            ctx.log.debug("Document body or html element is missing, using default height");
            return DEFAULT_HEIGHT;
          }
          const measurements = [
            (body == null ? void 0 : body.scrollHeight) || 0,
            (body == null ? void 0 : body.offsetHeight) || 0,
            (html == null ? void 0 : html.clientHeight) || 0,
            (html == null ? void 0 : html.scrollHeight) || 0,
            (html == null ? void 0 : html.offsetHeight) || 0
          ];
          const allMeasurementsInvalid = measurements.every((measurement) => !measurement);
          if (allMeasurementsInvalid) {
            ctx.log.debug("All height measurements are invalid, using default height");
            return DEFAULT_HEIGHT;
          }
          return Math.max(...measurements);
        });
        ctx.log.debug(`Calculated content height: ${height}`);
        let locators = [];
        if (!Array.isArray(processedOptions[ignoreOrSelectBoxes][viewportString]))
          processedOptions[ignoreOrSelectBoxes][viewportString] = [];
        for (const selector of selectors) {
          let l = yield page.locator(selector).all();
          if (l.length === 0) {
            optionWarnings.add(`for snapshot ${snapshot.name} viewport ${viewportString}, no element found for selector ${selector}`);
            continue;
          }
          locators.push(...l);
        }
        for (const locator of locators) {
          let bb = yield locator.boundingBox();
          if (bb) {
            const top = bb.y;
            const bottom = bb.y + bb.height;
            if (top <= height && bottom <= height) {
              processedOptions[ignoreOrSelectBoxes][viewportString].push({
                left: bb.x,
                top,
                right: bb.x + bb.width,
                bottom
              });
            } else {
              ctx.log.debug(`Bounding box for selector skipped due to exceeding height: ${JSON.stringify({ top, bottom, height })}`);
            }
          }
        }
      }
      processedOptions.ignoreDOM = options == null ? void 0 : options.ignoreDOM;
      processedOptions.selectDOM = options == null ? void 0 : options.selectDOM;
      ctx.log.debug(`Processed options: ${JSON.stringify(processedOptions)}`);
    }
    let hasBrowserErrors = false;
    for (let browser in discoveryErrors.browsers) {
      if (discoveryErrors.browsers[browser]) {
        for (let viewport in discoveryErrors.browsers[browser]) {
          if (discoveryErrors.browsers[browser][viewport].length > 0) {
            hasBrowserErrors = true;
            ctx.build.hasDiscoveryError = true;
            break;
          }
        }
      }
    }
    if (hasBrowserErrors) {
      discoveryErrors.timestamp = (/* @__PURE__ */ new Date()).toISOString();
    }
    if (ctx.config.useGlobalCache) {
      const keys = globalCache.keys();
      keys.forEach((key) => {
        if (!(key in cache)) {
          const globalCacheData = globalCache.get(key);
          if (globalCacheData) {
            cache[key] = globalCacheData;
          }
        }
      });
    }
    return {
      processedSnapshot: {
        name: snapshot.name,
        url: snapshot.url,
        dom: Buffer.from(snapshot.dom.html).toString("base64"),
        resources: cache,
        options: processedOptions
      },
      warnings: [...optionWarnings, ...snapshot.dom.warnings],
      discoveryErrors
    };
  });
}
var Queue = class {
  constructor(ctx) {
    this.snapshots = [];
    this.processedSnapshots = [];
    this.processing = false;
    this.processingSnapshot = "";
    this.snapshotNames = [];
    this.variants = [];
    this.ctx = ctx;
  }
  enqueue(item) {
    this.snapshots.push(item);
    if (!this.ctx.config.delayedUpload) {
      if (!this.processing) {
        this.processing = true;
        this.processNext();
      }
    }
  }
  startProcessingfunc() {
    if (!this.processing) {
      this.processing = true;
      this.processNext();
    }
  }
  processGenerateVariants(snapshot) {
    if (snapshot.options) {
      if (snapshot.options.web) {
        this.generateWebVariants(snapshot, snapshot.options.web);
      }
      if (snapshot.options.mobile) {
        this.generateMobileVariants(snapshot, snapshot.options.mobile);
      }
    }
    if (!snapshot.options || snapshot.options && !snapshot.options.web && !snapshot.options.mobile) {
      this.generateVariants(snapshot, this.ctx.config);
    }
  }
  generateVariants(snapshot, config) {
    if (config.web) {
      const browsers = config.web.browsers || [];
      const viewports = config.web.viewports || [];
      for (const browser of browsers) {
        for (const viewport of viewports) {
          const width = viewport.width;
          const height = viewport.height || 0;
          const variant = `${snapshot.name}_${browser}_viewport[${width}]_viewport[${height}]`;
          this.variants.push(variant);
        }
      }
    }
    if (config.mobile) {
      const devices = config.mobile.devices || [];
      const orientation = config.mobile.orientation || constants_default.MOBILE_ORIENTATION_PORTRAIT;
      for (const device of devices) {
        const variant = `${snapshot.name}_${device}_${orientation}`;
        this.variants.push(variant);
      }
    }
  }
  generateWebVariants(snapshot, webConfig) {
    var _a, _b, _c;
    const browsers = (_c = (_b = webConfig.browsers) != null ? _b : (_a = this.ctx.config.web) == null ? void 0 : _a.browsers) != null ? _c : [constants_default.CHROME, constants_default.EDGE, constants_default.FIREFOX, constants_default.SAFARI];
    const viewports = webConfig.viewports || [];
    for (const browser of browsers) {
      for (const viewport of viewports) {
        const width = viewport[0];
        const height = viewport[1] || 0;
        const variant = `${snapshot.name}_${browser}_viewport[${width}]_viewport[${height}]`;
        this.variants.push(variant);
      }
    }
  }
  generateMobileVariants(snapshot, mobileConfig) {
    var _a, _b, _c;
    const devices = mobileConfig.devices || [];
    const orientation = (_c = (_b = mobileConfig.orientation) != null ? _b : (_a = this.ctx.config.mobile) == null ? void 0 : _a.orientation) != null ? _c : constants_default.MOBILE_ORIENTATION_PORTRAIT;
    for (const device of devices) {
      const variant = `${snapshot.name}_${device}_${orientation}`;
      this.variants.push(variant);
    }
  }
  filterExistingVariants(snapshot, config) {
    let drop = true;
    if (snapshot.options && snapshot.options.web) {
      const webDrop = this.filterWebVariants(snapshot, snapshot.options.web);
      if (!webDrop)
        drop = false;
    }
    if (snapshot.options && snapshot.options.mobile) {
      const mobileDrop = this.filterMobileVariants(snapshot, snapshot.options.mobile);
      if (!mobileDrop)
        drop = false;
    }
    if (!snapshot.options || snapshot.options && !snapshot.options.web && !snapshot.options.mobile) {
      const configDrop = this.filterVariants(snapshot, config);
      if (!configDrop)
        drop = false;
    }
    return drop;
  }
  filterVariants(snapshot, config) {
    var _a;
    let allVariantsDropped = true;
    if (config.web) {
      const browsers = config.web.browsers || [];
      const viewports = config.web.viewports || [];
      for (const browser of browsers) {
        for (const viewport of viewports) {
          const width = viewport.width;
          const height = viewport.height || 0;
          const variant = `${snapshot.name}_${browser}_viewport[${width}]_viewport[${height}]`;
          if (!this.variants.includes(variant)) {
            allVariantsDropped = false;
            if (!snapshot.options)
              snapshot.options = {};
            if (!snapshot.options.web)
              snapshot.options.web = { browsers: [], viewports: [] };
            if (!snapshot.options.web.browsers.includes(browser)) {
              snapshot.options.web.browsers.push(browser);
            }
            const viewportExists = snapshot.options.web.viewports.some(
              (existingViewport) => existingViewport[0] === width && (existingViewport.length < 2 || existingViewport[1] === height)
            );
            if (!viewportExists) {
              if (height > 0) {
                snapshot.options.web.viewports.push([width, height]);
              } else {
                snapshot.options.web.viewports.push([width]);
              }
            }
          }
        }
      }
    }
    if (config.mobile) {
      const devices = config.mobile.devices || [];
      const orientation = config.mobile.orientation || constants_default.MOBILE_ORIENTATION_PORTRAIT;
      const fullPage = (_a = config.mobile.fullPage) != null ? _a : true;
      for (const device of devices) {
        const variant = `${snapshot.name}_${device}_${orientation}`;
        if (!this.variants.includes(variant)) {
          allVariantsDropped = false;
          if (!snapshot.options)
            snapshot.options = {};
          if (!snapshot.options.mobile)
            snapshot.options.mobile = { devices: [], orientation: constants_default.MOBILE_ORIENTATION_PORTRAIT, fullPage };
          if (!snapshot.options.mobile.devices.includes(device)) {
            snapshot.options.mobile.devices.push(device);
          }
          snapshot.options.mobile.orientation = orientation;
        }
      }
    }
    return allVariantsDropped;
  }
  filterWebVariants(snapshot, webConfig) {
    var _a, _b, _c;
    const browsers = (_c = (_b = webConfig.browsers) != null ? _b : (_a = this.ctx.config.web) == null ? void 0 : _a.browsers) != null ? _c : [constants_default.CHROME, constants_default.EDGE, constants_default.FIREFOX, constants_default.SAFARI];
    const viewports = webConfig.viewports || [];
    let allVariantsDropped = true;
    if (!snapshot.options) {
      snapshot.options = {};
    }
    snapshot.options.web = { browsers: [], viewports: [] };
    for (const browser of browsers) {
      for (const viewport of viewports) {
        const width = viewport[0];
        const height = viewport[1] || 0;
        const variant = `${snapshot.name}_${browser}_viewport[${width}]_viewport[${height}]`;
        if (!this.variants.includes(variant)) {
          allVariantsDropped = false;
          if (!snapshot.options.web.browsers.includes(browser)) {
            snapshot.options.web.browsers.push(browser);
          }
          const viewportExists = snapshot.options.web.viewports.some(
            (existingViewport) => existingViewport[0] === width && (existingViewport.length < 2 || existingViewport[1] === height)
          );
          if (!viewportExists) {
            if (height > 0) {
              snapshot.options.web.viewports.push([width, height]);
            } else {
              snapshot.options.web.viewports.push([width]);
            }
          }
        }
      }
    }
    return allVariantsDropped;
  }
  filterMobileVariants(snapshot, mobileConfig) {
    var _a, _b, _c, _d, _e, _f;
    if (!snapshot.options) {
      snapshot.options = {};
    }
    const devices = mobileConfig.devices || [];
    const orientation = (_c = (_b = mobileConfig.orientation) != null ? _b : (_a = this.ctx.config.mobile) == null ? void 0 : _a.orientation) != null ? _c : constants_default.MOBILE_ORIENTATION_PORTRAIT;
    const fullPage = (_f = (_e = mobileConfig.fullPage) != null ? _e : (_d = this.ctx.config.mobile) == null ? void 0 : _d.fullPage) != null ? _f : true;
    let allVariantsDropped = true;
    snapshot.options.mobile = { devices: [], orientation: constants_default.MOBILE_ORIENTATION_PORTRAIT, fullPage };
    for (const device of devices) {
      const variant = `${snapshot.name}_${device}_${orientation}`;
      if (!this.variants.includes(variant)) {
        allVariantsDropped = false;
        snapshot.options.mobile.devices.push(device);
        snapshot.options.mobile.orientation = orientation;
      }
    }
    return allVariantsDropped;
  }
  processNext() {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      if (!this.isEmpty()) {
        let snapshot;
        if (this.ctx.config.delayedUpload) {
          snapshot = this.snapshots.pop();
        } else {
          snapshot = this.snapshots.shift();
        }
        try {
          this.processingSnapshot = snapshot == null ? void 0 : snapshot.name;
          let drop = false;
          if (this.ctx.isStartExec && !this.ctx.config.tunnel) {
            this.ctx.log.info(`Processing Snapshot: ${snapshot == null ? void 0 : snapshot.name}`);
          }
          if (!this.ctx.config.delayedUpload && snapshot && snapshot.name && this.snapshotNames.includes(snapshot.name)) {
            drop = true;
            this.ctx.log.info(`Skipping duplicate SmartUI snapshot '${snapshot.name}'. To capture duplicate screenshots, please set the 'delayedUpload' configuration as true in your config file.`);
          }
          if (this.ctx.config.delayedUpload && snapshot && snapshot.name && this.snapshotNames.includes(snapshot.name)) {
            drop = this.filterExistingVariants(snapshot, this.ctx.config);
          }
          if (snapshot && snapshot.name && !this.snapshotNames.includes(snapshot.name) && !drop) {
            this.snapshotNames.push(snapshot.name);
          }
          if (this.ctx.config.delayedUpload && snapshot && !drop) {
            this.processGenerateVariants(snapshot);
          }
          if (!drop) {
            const sessionId = (_a = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _a.sessionId;
            let capsBuildId = "";
            let capsProjectToken = "";
            let useCapsBuildId = false;
            let useKafkaFlowCaps = false;
            if (sessionId && ((_b = this.ctx.sessionCapabilitiesMap) == null ? void 0 : _b.has(sessionId))) {
              const cachedCapabilities = this.ctx.sessionCapabilitiesMap.get(sessionId);
              capsProjectToken = (cachedCapabilities == null ? void 0 : cachedCapabilities.projectToken) || "";
              capsBuildId = (cachedCapabilities == null ? void 0 : cachedCapabilities.buildId) || "";
              useKafkaFlowCaps = (cachedCapabilities == null ? void 0 : cachedCapabilities.useKafkaFlow) || false;
              if (capsBuildId != "" && capsProjectToken != "") {
                useCapsBuildId = true;
              }
            }
            let processedSnapshot, warnings, discoveryErrors;
            if (this.ctx.env.USE_REMOTE_DISCOVERY) {
              this.ctx.log.debug(`Using remote discovery`);
              let result = yield prepareSnapshot(snapshot, this.ctx);
              processedSnapshot = result.processedSnapshot;
              warnings = result.warnings;
            } else {
              this.ctx.log.debug(`Using local discovery`);
              let result = yield processSnapshot(snapshot, this.ctx);
              processedSnapshot = result.processedSnapshot;
              warnings = result.warnings;
              discoveryErrors = result.discoveryErrors;
            }
            if (useCapsBuildId) {
              if (useKafkaFlowCaps) {
                const snapshotUuid = uuid.v4();
                const presignedResponse = yield this.ctx.client.getS3PresignedURLForSnapshotUploadCaps(this.ctx, processedSnapshot.name, snapshotUuid, capsBuildId, capsProjectToken);
                const uploadUrl = presignedResponse.data.url;
                yield this.ctx.client.uploadSnapshotToS3Caps(this.ctx, uploadUrl, processedSnapshot, capsProjectToken);
                yield this.ctx.client.processSnapshotCaps(this.ctx, processedSnapshot, snapshotUuid, capsBuildId, capsProjectToken, discoveryErrors);
              } else {
                yield this.ctx.client.uploadSnapshotForCaps(this.ctx, processedSnapshot, capsBuildId, capsProjectToken, discoveryErrors);
              }
              const cachedCapabilities = this.ctx.sessionCapabilitiesMap.get(sessionId);
              const currentCount = (cachedCapabilities == null ? void 0 : cachedCapabilities.snapshotCount) || 0;
              cachedCapabilities.snapshotCount = currentCount + 1;
              this.ctx.sessionCapabilitiesMap.set(sessionId, cachedCapabilities);
            } else {
              if (!((_c = this.ctx.build) == null ? void 0 : _c.id)) {
                if (this.ctx.authenticatedInitially) {
                  let resp = yield this.ctx.client.createBuild(this.ctx.git, this.ctx.config, this.ctx.log, this.ctx.build.name, false, false, false, "");
                  this.ctx.build = {
                    id: resp.data.buildId,
                    name: resp.data.buildName,
                    url: resp.data.buildURL,
                    baseline: resp.data.baseline,
                    useKafkaFlow: resp.data.useKafkaFlow || false
                  };
                } else {
                  if (this.ctx.config.tunnel && ((_d = this.ctx.config.tunnel) == null ? void 0 : _d.type) === "auto") {
                    yield stopTunnelHelper(this.ctx);
                  }
                  throw new Error("SmartUI capabilities are missing in env variables or in driver capabilities");
                }
                if (this.ctx.options.fetchResults) {
                  if (this.ctx.build && this.ctx.build.id) {
                    startPolling(this.ctx, "", false, "");
                  }
                }
              }
              if (this.ctx.build && this.ctx.build.useKafkaFlow) {
                const snapshotUuid = uuid.v4();
                const presignedResponse = yield this.ctx.client.getS3PresignedURLForSnapshotUpload(this.ctx, processedSnapshot.name, snapshotUuid);
                const uploadUrl = presignedResponse.data.url;
                let snapshotUploadResponse = yield this.ctx.client.uploadSnapshotToS3(this.ctx, uploadUrl, processedSnapshot);
                if (!snapshotUploadResponse || Object.keys(snapshotUploadResponse).length === 0) {
                  this.ctx.log.debug(`snapshot failed; Unable to upload dom to S3`);
                  this.processedSnapshots.push({ name: snapshot == null ? void 0 : snapshot.name, error: `snapshot failed; Unable to upload dom to S3` });
                  if (this.ctx.browser) {
                    for (let context of this.ctx.browser.contexts()) {
                      for (let page of context.pages()) {
                        yield page.close();
                        this.ctx.log.debug(`Closed browser page for snapshot ${snapshot.name}`);
                      }
                      yield context.close();
                      this.ctx.log.debug(`Closed browser context for snapshot ${snapshot.name}`);
                    }
                  }
                  this.processNext();
                } else {
                  yield this.ctx.client.processSnapshot(this.ctx, processedSnapshot, snapshotUuid, discoveryErrors);
                }
              } else {
                yield this.ctx.client.uploadSnapshot(this.ctx, processedSnapshot, discoveryErrors);
              }
              this.ctx.totalSnapshots++;
            }
            this.processedSnapshots.push({ name: snapshot == null ? void 0 : snapshot.name, warnings });
          }
        } catch (error) {
          this.ctx.log.debug(`snapshot failed; ${error}`);
          this.processedSnapshots.push({ name: snapshot == null ? void 0 : snapshot.name, error: error.message });
        }
        if (this.ctx.browser) {
          for (let context of this.ctx.browser.contexts()) {
            for (let page of context.pages()) {
              yield page.close();
              this.ctx.log.debug(`Closed browser page for snapshot ${snapshot.name}`);
            }
            yield context.close();
            this.ctx.log.debug(`Closed browser context for snapshot ${snapshot.name}`);
          }
        }
        this.processNext();
      } else {
        this.processing = false;
      }
    });
  }
  isProcessing() {
    return this.processing;
  }
  getProcessingSnapshot() {
    return this.processingSnapshot;
  }
  getProcessedSnapshots() {
    return this.processedSnapshots;
  }
  isEmpty() {
    return this.snapshots && this.snapshots.length ? false : true;
  }
};
var startTunnel_default = (ctx) => {
  return {
    title: `Starting Tunnel`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "startTunnel" });
      try {
        yield startTunnelBinary(ctx2);
        ctx2.isStartExec = true;
        task.title = "Tunnel Started";
        task.output = chalk__default.default.gray("Tunnel started successfully");
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Error while starting tunnel binary");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};

// src/commander/exec.ts
var command = new commander.Command();
command.name("exec").description("Run test commands around SmartUI").argument("<command...>", "Command supplied for running tests").option("-P, --port <number>", "Port number for the server").option("--fetch-results [filename]", "Fetch results and optionally specify an output file, e.g., <filename>.json").option("--buildName <string>", "Specify the build name").option("--userName <string>", "Specify the LT username").option("--accessKey <string>", "Specify the LT accesskey").action(function(execCommand, _, command9) {
  return __async(this, null, function* () {
    var _a;
    const options = command9.optsWithGlobals();
    if (options.buildName === "") {
      console.log(`Error: The '--buildName' option cannot be an empty string.`);
      process.exit(1);
    }
    let ctx = ctx_default(command9.optsWithGlobals());
    if (!which__default.default.sync(execCommand[0], { nothrow: true })) {
      ctx.log.error(`Error: Command not found "${execCommand[0]}"`);
      return;
    }
    ctx.args.execCommand = execCommand;
    ctx.snapshotQueue = new Queue(ctx);
    ctx.totalSnapshots = 0;
    let tasks = new listr2.Listr(
      [
        authExec_default(),
        startServer_default(),
        getGitInfo_default(),
        ...ctx.config.tunnel && ((_a = ctx.config.tunnel) == null ? void 0 : _a.type) === "auto" ? [startTunnel_default()] : [],
        createBuildExec_default(),
        exec_default(ctx),
        processSnapshot_default(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      ctx.log.info("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
      throw new Error();
    }
  });
});
var exec_default2 = command;
function createConfig(filepath) {
  filepath = filepath || ".smartui.json";
  let filetype = path2__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: Config file must have .json extension");
    return;
  }
  if (fs5__default.default.existsSync(filepath)) {
    console.log(`Error: SmartUI Config already exists: ${filepath}`);
    console.log(`To create a new file, please specify the file name like: 'smartui config:create .smartui-config.json'`);
    return;
  }
  fs5__default.default.mkdirSync(path2__default.default.dirname(filepath), { recursive: true });
  fs5__default.default.writeFileSync(filepath, JSON.stringify(constants_default.DEFAULT_CONFIG, null, 2) + "\n");
  console.log(`Created SmartUI Config: ${filepath}`);
}
function createWebStaticConfig(filepath) {
  filepath = filepath || "url.json";
  let filetype = path2__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: Config file must have .json extension");
    return;
  }
  if (fs5__default.default.existsSync(filepath)) {
    console.log(`Error: web-static config already exists: ${filepath}`);
    console.log(`To create a new file, please specify the file name like: 'smartui config:create-web-static links.json'`);
    return;
  }
  fs5__default.default.mkdirSync(path2__default.default.dirname(filepath), { recursive: true });
  fs5__default.default.writeFileSync(filepath, JSON.stringify(constants_default.DEFAULT_WEB_STATIC_CONFIG, null, 2) + "\n");
  console.log(`Created web-static config: ${filepath}`);
}
function createFigmaConfig(filepath) {
  filepath = filepath || "designs.json";
  let filetype = path2__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: designs config file must have .json extension");
    return;
  }
  if (fs5__default.default.existsSync(filepath)) {
    console.log(`Error: designs config already exists: ${filepath}`);
    console.log(`To create a new file, please specify the file name like: 'smartui config:figma-config designs.json'`);
    return;
  }
  fs5__default.default.mkdirSync(path2__default.default.dirname(filepath), { recursive: true });
  fs5__default.default.writeFileSync(filepath, JSON.stringify(constants_default.DEFAULT_FIGMA_CONFIG, null, 2) + "\n");
  console.log(`Created designs config: ${filepath}`);
}
function createWebFigmaConfig(filepath) {
  filepath = filepath || ".smartui.json";
  let filetype = path2__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: figma config file must have .json extension");
    return;
  }
  if (fs5__default.default.existsSync(filepath)) {
    console.log(`Error: figma config already exists: ${filepath}`);
    console.log(`To create a new file, please specify the file name like: 'smartui config:create-figma-web <fileName>.json'`);
    return;
  }
  fs5__default.default.mkdirSync(path2__default.default.dirname(filepath), { recursive: true });
  fs5__default.default.writeFileSync(filepath, JSON.stringify(constants_default.WEB_FIGMA_CONFIG, null, 2) + "\n");
  console.log(`Created figma web config: ${filepath}`);
}
function verifyFigmaWebConfig(ctx) {
  var _a, _b;
  if (ctx.env.FIGMA_TOKEN == "") {
    throw new Error("Missing FIGMA_TOKEN in Environment Variables");
  }
  if (ctx.env.LT_USERNAME == "") {
    throw new Error("Missing LT_USERNAME in Environment Variables");
  }
  if (ctx.env.LT_ACCESS_KEY == "") {
    throw new Error("Missing LT_ACCESS_KEY in Environment Variables");
  }
  let figma = ctx.config && ((_a = ctx.config) == null ? void 0 : _a.figma) || {};
  const screenshots = [];
  for (let c of figma == null ? void 0 : figma.configs) {
    if (c.screenshot_names && c.screenshot_names.length > 0 && c.figma_ids && c.figma_ids.length != c.screenshot_names.length) {
      throw new Error("Mismatch in Figma Ids and Screenshot Names in figma config");
    }
    if (isValidArray(c.screenshot_names)) {
      for (const name of c.screenshot_names) {
        screenshots.push(name);
      }
    }
  }
  if (new Set(screenshots).size !== screenshots.length) {
    throw new Error("Found duplicate screenshot names in figma config");
  }
  let mobileConfig = ((_b = ctx.config) == null ? void 0 : _b.mobile) || {};
  if (Array.isArray(mobileConfig)) {
    for (const config of mobileConfig) {
      const deviceName = config.name;
      if (constants_default.SUPPORTED_MOBILE_DEVICES[deviceName]) {
        const deviceData = constants_default.SUPPORTED_MOBILE_DEVICES[deviceName];
        config.width = deviceData.viewport.width;
        config.height = deviceData.viewport.height;
      }
    }
  }
}
function isValidArray(input) {
  return Array.isArray(input) && input.length > 0;
}
function createAppFigmaConfig(filepath) {
  filepath = filepath || ".smartui.json";
  let filetype = path2__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: figma app config file must have .json extension");
    return;
  }
  if (fs5__default.default.existsSync(filepath)) {
    console.log(`Error: figma app config already exists: ${filepath}`);
    console.log(`To create a new figma app config, please specify the file name like: 'smartui config:create-figma-app <fileName>.json'`);
    return;
  }
  fs5__default.default.mkdirSync(path2__default.default.dirname(filepath), { recursive: true });
  fs5__default.default.writeFileSync(filepath, JSON.stringify(constants_default.APP_FIGMA_CONFIG, null, 2) + "\n");
  console.log(`Created figma app config: ${filepath}`);
}

// src/commander/config.ts
var configWeb = new commander.Command();
var configStatic = new commander.Command();
var configFigma = new commander.Command();
var configWebFigma = new commander.Command();
var configAppFigma = new commander.Command();
configWeb.name("config:create").description("Create SmartUI config file").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createConfig(filepath);
  });
});
configStatic.name("config:create-web-static").description("Create Web Static config file").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createWebStaticConfig(filepath);
  });
});
configFigma.name("config:create-figma").description("Create figma designs config file").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createFigmaConfig(filepath);
  });
});
configWebFigma.name("config:create-figma-web").description("Create figma config file with browsers").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createWebFigmaConfig(filepath);
  });
});
configAppFigma.name("config:create-figma-app").description("Create figma config file for mobile apps").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createAppFigmaConfig(filepath);
  });
});
var auth_default = (ctx) => {
  return {
    title: `Authenticating with SmartUI`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "auth" });
      try {
        const authResult = yield ctx2.client.auth(ctx2.log, ctx2.env);
        if (authResult === 2) {
          task.output = chalk__default.default.gray(`New project '${ctx2.env.PROJECT_NAME}' created successfully`);
        } else if (authResult === 0) {
          task.output = chalk__default.default.gray(`Using existing project token '******#${ctx2.env.PROJECT_TOKEN.split("#").pop()}'`);
        } else if (authResult === 1) {
          task.output = chalk__default.default.gray(`Using existing project '${ctx2.env.PROJECT_NAME}'`);
        }
        task.title = "Authenticated with SmartUI";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Authentication failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var createBuild_default = (ctx) => {
  return {
    title: `Creating SmartUI build`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "createBuild" });
      try {
        let resp = yield ctx2.client.createBuild(ctx2.git, ctx2.config, ctx2.log, ctx2.build.name, ctx2.isStartExec, ctx2.env.SMART_GIT, ctx2.options.markBaseline, ctx2.options.baselineBuild);
        if (resp && resp.data && resp.data.buildId) {
          ctx2.build = {
            id: resp.data.buildId,
            name: resp.data.buildName,
            url: resp.data.buildURL,
            baseline: resp.data.baseline,
            useKafkaFlow: resp.data.useKafkaFlow || false
          };
        } else if (resp && resp.error) {
          if (resp.error.message) {
            ctx2.log.error(`Error while creation of build: ${resp.error.message}`);
            throw new Error(`Error while creation of build: ${resp.error.message}`);
          }
        }
        task.output = chalk__default.default.gray(`build id: ${resp.data.buildId}`);
        task.title = "SmartUI build created";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("SmartUI build creation failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
function captureScreenshotsForConfig(ctx, browsers, urlConfig, browserName, renderViewports) {
  return __async(this, null, function* () {
    ctx.log.debug(`*** urlConfig  ${JSON.stringify(urlConfig)}`);
    let { name, url, waitForTimeout, execute, pageEvent, userAgent } = urlConfig;
    let afterNavigationScript = execute == null ? void 0 : execute.afterNavigation;
    let beforeSnapshotScript = execute == null ? void 0 : execute.beforeSnapshot;
    let waitUntilEvent = pageEvent || process.env.SMARTUI_PAGE_WAIT_UNTIL_EVENT || "load";
    let pageOptions = { waitUntil: waitUntilEvent, timeout: ctx.config.waitForPageRender || constants_default.DEFAULT_PAGE_LOAD_TIMEOUT };
    ctx.log.debug(`url:  ${url}  pageOptions: ${JSON.stringify(pageOptions)}`);
    let ssId = name.toLowerCase().replace(/\s/g, "_");
    let context;
    let contextOptions = {};
    let page;
    if (browserName == constants_default.CHROME)
      contextOptions.userAgent = constants_default.CHROME_USER_AGENT;
    else if (browserName == constants_default.FIREFOX)
      contextOptions.userAgent = constants_default.FIREFOX_USER_AGENT;
    else if (browserName == constants_default.SAFARI)
      contextOptions.userAgent = constants_default.SAFARI_USER_AGENT;
    else if (browserName == constants_default.EDGE)
      contextOptions.userAgent = constants_default.EDGE_USER_AGENT;
    if (ctx.config.userAgent || userAgent) {
      if (ctx.config.userAgent !== "") {
        contextOptions.userAgent = ctx.config.userAgent;
      }
      if (userAgent && userAgent !== "") {
        contextOptions.userAgent = userAgent;
      }
    }
    try {
      const browser = browsers[browserName];
      context = yield browser == null ? void 0 : browser.newContext(contextOptions);
      page = yield context == null ? void 0 : context.newPage();
      yield page == null ? void 0 : page.goto(url.trim(), pageOptions);
      yield executeDocumentScripts(ctx, page, "afterNavigation", afterNavigationScript);
      for (let { viewport, viewportString, fullPage } of renderViewports) {
        let ssPath = `screenshots/${ssId}/${`${browserName}-${viewport.width}x${viewport.height}`}-${ssId}.png`;
        yield page == null ? void 0 : page.setViewportSize({ width: viewport.width, height: viewport.height || constants_default.MIN_VIEWPORT_HEIGHT });
        if (fullPage)
          yield page == null ? void 0 : page.evaluate(scrollToBottomAndBackToTop);
        yield page == null ? void 0 : page.waitForTimeout(waitForTimeout || 0);
        yield executeDocumentScripts(ctx, page, "beforeSnapshot", beforeSnapshotScript);
        yield page == null ? void 0 : page.screenshot({ path: ssPath, fullPage });
        yield ctx.client.uploadScreenshot(ctx.build, ssPath, name, browserName, viewportString, ctx.log);
      }
    } catch (error) {
      throw new Error(`captureScreenshotsForConfig failed for browser ${browserName}; error: ${error}`);
    } finally {
      yield page == null ? void 0 : page.close();
      yield context == null ? void 0 : context.close();
    }
  });
}
function captureScreenshotsAsync(ctx, staticConfig, browsers) {
  return __async(this, null, function* () {
    let capturePromises = [];
    if (ctx.config.web) {
      for (let browserName of ctx.config.web.browsers) {
        let webRenderViewports = getWebRenderViewports(ctx);
        capturePromises.push(captureScreenshotsForConfig(ctx, browsers, staticConfig, browserName, webRenderViewports));
      }
    }
    if (ctx.config.mobile) {
      let mobileRenderViewports = getMobileRenderViewports(ctx);
      if (mobileRenderViewports[constants_default.MOBILE_OS_IOS].length) {
        capturePromises.push(captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.SAFARI, mobileRenderViewports[constants_default.MOBILE_OS_IOS]));
      }
      if (mobileRenderViewports[constants_default.MOBILE_OS_ANDROID].length) {
        capturePromises.push(captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.CHROME, mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]));
      }
    }
    return Promise.all(capturePromises);
  });
}
function captureScreenshotsSync(ctx, staticConfig, browsers) {
  return __async(this, null, function* () {
    if (ctx.config.web) {
      for (let browserName of ctx.config.web.browsers) {
        let webRenderViewports = getWebRenderViewports(ctx);
        yield captureScreenshotsForConfig(ctx, browsers, staticConfig, browserName, webRenderViewports);
      }
    }
    if (ctx.config.mobile) {
      let mobileRenderViewports = getMobileRenderViewports(ctx);
      if (mobileRenderViewports[constants_default.MOBILE_OS_IOS].length) {
        yield captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.SAFARI, mobileRenderViewports[constants_default.MOBILE_OS_IOS]);
      }
      if (mobileRenderViewports[constants_default.MOBILE_OS_ANDROID].length) {
        yield captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.CHROME, mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]);
      }
    }
  });
}
function captureScreenshots(ctx) {
  return __async(this, null, function* () {
    delDir("screenshots");
    let browsers = {};
    let capturedScreenshots = 0;
    let output = "";
    try {
      browsers = yield launchBrowsers(ctx);
    } catch (error) {
      yield closeBrowsers(browsers);
      ctx.log.debug(error);
      throw new Error(`Failed launching browsers`);
    }
    for (let staticConfig of ctx.webStaticConfig) {
      try {
        if (ctx.options.parallel)
          yield captureScreenshotsAsync(ctx, staticConfig, browsers);
        else
          yield captureScreenshotsSync(ctx, staticConfig, browsers);
        delDir(`screenshots/${staticConfig.name.toLowerCase().replace(/\s/g, "_")}`);
        output += `${chalk__default.default.gray(staticConfig.name)} ${chalk__default.default.green("\u2713")}
`;
        ctx.task.output = output;
        capturedScreenshots++;
      } catch (error) {
        ctx.log.debug(`captureScreenshots failed for ${JSON.stringify(staticConfig)}; error: ${error}`);
        output += `${chalk__default.default.gray(staticConfig.name)} ${chalk__default.default.red("\u2717")}
`;
        ctx.task.output = output;
      }
    }
    yield closeBrowsers(browsers);
    delDir("screenshots");
    return { capturedScreenshots, output };
  });
}
function getImageDimensions(filePath) {
  const buffer = fs5__default.default.readFileSync(filePath);
  let width, height;
  if (buffer.toString("hex", 0, 2) === "ffd8") {
    let offset = 2;
    while (offset < buffer.length) {
      const marker = buffer.toString("hex", offset, offset + 2);
      offset += 2;
      const length = buffer.readUInt16BE(offset);
      if (marker === "ffc0" || marker === "ffc2") {
        height = buffer.readUInt16BE(offset + 3);
        width = buffer.readUInt16BE(offset + 5);
        return { width, height };
      }
      offset += length;
    }
  } else if (buffer.toString("hex", 1, 4) === "504e47") {
    width = buffer.readUInt32BE(16);
    height = buffer.readUInt32BE(20);
    return { width, height };
  }
  return null;
}
function isAllowedImage(filePath) {
  return __async(this, null, function* () {
    try {
      const fileBuffer = fs5__default.default.readFileSync(filePath);
      const isMagicValid = constants_default.MAGIC_NUMBERS.some((magic) => fileBuffer.slice(0, magic.magic.length).equals(magic.magic));
      const metadata = yield sharp__default.default(filePath).metadata();
      if (metadata.format === constants_default.FILE_EXTENSION_GIFS) {
        return false;
      }
      if (metadata.width > 0 && metadata.height > 0) {
        return true;
      }
      if (isMagicValid && metadata.format !== constants_default.FILE_EXTENSION_GIFS) {
        return true;
      }
      return false;
    } catch (error) {
      return false;
    }
  });
}
function uploadScreenshots(ctx) {
  return __async(this, null, function* () {
    const allowedExtensions = ctx.options.fileExtension.map((ext) => `.${ext.trim().toLowerCase()}`);
    let noOfScreenshots = 0;
    function processDirectory(directory, relativePath = "") {
      return __async(this, null, function* () {
        const files = fs5__default.default.readdirSync(directory);
        for (let file of files) {
          const filePath = path2__default.default.join(directory, file);
          const stat = fs5__default.default.statSync(filePath);
          const relativeFilePath = path2__default.default.join(relativePath, file);
          if (stat.isDirectory() && ctx.options.ignorePattern.includes(relativeFilePath)) {
            ctx.log.info(`Ignoring Directory ${relativeFilePath}`);
            continue;
          }
          if (stat.isDirectory()) {
            yield processDirectory(filePath, relativeFilePath);
          } else {
            let fileExtension = path2__default.default.extname(file).toLowerCase();
            if (allowedExtensions.includes(fileExtension)) {
              const isValid = yield isAllowedImage(filePath);
              if (!isValid) {
                ctx.log.info(`File ${filePath} is not a valid ${fileExtension} image or is corrupted. Skipping.`);
                continue;
              }
              let ssId = relativeFilePath;
              if (ctx.options.stripExtension) {
                ssId = path2__default.default.join(relativePath, path2__default.default.basename(file, fileExtension));
              }
              let viewport = "default";
              if (!ctx.options.ignoreResolutions) {
                const dimensions = getImageDimensions(filePath);
                if (!dimensions) {
                  ctx.log.info(`Unable to determine dimensions for image: ${filePath}`);
                } else {
                  const width = dimensions.width;
                  const height = dimensions.height;
                  viewport = `${width}x${height}`;
                }
              }
              yield ctx.client.uploadScreenshot(ctx.build, filePath, ssId, "default", viewport, ctx.log);
              ctx.log.info(`${filePath} : uploaded successfully`);
              noOfScreenshots++;
            } else {
              ctx.log.info(`File ${filePath} has invalid file extension: ${fileExtension}. Skipping`);
            }
          }
        }
      });
    }
    yield processDirectory(ctx.uploadFilePath);
    if (noOfScreenshots == 0) {
      ctx.log.info(`No screenshots uploaded.`);
    } else {
      ctx.log.info(`${noOfScreenshots} screenshots uploaded successfully.`);
    }
  });
}
function captureScreenshotsConcurrent(ctx) {
  return __async(this, null, function* () {
    delDir("screenshots");
    let totalSnapshots = ctx.webStaticConfig && ctx.webStaticConfig.length;
    let browserInstances = ctx.options.parallel || 1;
    let optimizeBrowserInstances = 0;
    optimizeBrowserInstances = Math.floor(Math.log2(totalSnapshots));
    if (optimizeBrowserInstances < 1) {
      optimizeBrowserInstances = 1;
    }
    if (optimizeBrowserInstances > browserInstances) {
      optimizeBrowserInstances = browserInstances;
    }
    if (ctx.options.force && browserInstances > 1) {
      optimizeBrowserInstances = browserInstances;
    }
    let urlsPerInstance = 0;
    if (optimizeBrowserInstances == 1) {
      urlsPerInstance = totalSnapshots;
    } else {
      urlsPerInstance = Math.ceil(totalSnapshots / optimizeBrowserInstances);
    }
    ctx.log.debug(`*** browserInstances requested ${ctx.options.parallel} `);
    ctx.log.debug(`*** optimizeBrowserInstances  ${optimizeBrowserInstances} `);
    ctx.log.debug(`*** urlsPerInstance  ${urlsPerInstance}`);
    ctx.task.output = `URLs : ${totalSnapshots} || Parallel Browser Instances: ${optimizeBrowserInstances}
`;
    let staticURLChunks = splitURLs(ctx.webStaticConfig, urlsPerInstance);
    let totalCapturedScreenshots = 0;
    let output = "";
    const responses = yield Promise.all(staticURLChunks.map((urlConfig) => __async(this, null, function* () {
      let { capturedScreenshots, finalOutput } = yield processChunk(ctx, urlConfig);
      return { capturedScreenshots, finalOutput };
    })));
    responses.forEach((response) => {
      totalCapturedScreenshots += response.capturedScreenshots;
      output += response.finalOutput;
    });
    delDir("screenshots");
    return { totalCapturedScreenshots, output };
  });
}
function splitURLs(arr, chunkSize) {
  const result = [];
  for (let i = 0; i < arr.length; i += chunkSize) {
    result.push(arr.slice(i, i + chunkSize));
  }
  return result;
}
function processChunk(ctx, urlConfig) {
  return __async(this, null, function* () {
    let browsers = {};
    let capturedScreenshots = 0;
    let finalOutput = "";
    try {
      browsers = yield launchBrowsers(ctx);
    } catch (error) {
      yield closeBrowsers(browsers);
      ctx.log.debug(error);
      throw new Error(`Failed launching browsers ${error}`);
    }
    for (let staticConfig of urlConfig) {
      try {
        yield captureScreenshotsAsync(ctx, staticConfig, browsers);
        delDir(`screenshots/${staticConfig.name.toLowerCase().replace(/\s/g, "_")}`);
        let output = `${chalk__default.default.gray(staticConfig.name)} ${chalk__default.default.green("\u2713")}
`;
        ctx.task.output = ctx.task.output ? ctx.task.output + output : output;
        finalOutput += output;
        capturedScreenshots++;
      } catch (error) {
        ctx.log.debug(`screenshot capture failed for ${JSON.stringify(staticConfig)}; error: ${error}`);
        let output = `${chalk__default.default.gray(staticConfig.name)} ${chalk__default.default.red("\u2717")}
`;
        ctx.task.output += output;
        finalOutput += output;
      }
    }
    yield closeBrowsers(browsers);
    return { capturedScreenshots, finalOutput };
  });
}
function executeDocumentScripts(ctx, page, actionType, script) {
  return __async(this, null, function* () {
    try {
      if (!page) {
        throw new Error("Page instance not available");
      }
      if (script !== "") {
        yield page.evaluate((script2) => {
          new Function(script2)();
        }, script);
      }
    } catch (error) {
      ctx.log.error(`Error executing script for action ${actionType}: `, error);
      throw error;
    }
  });
}
var captureScreenshots_default = (ctx) => {
  return {
    title: "Capturing screenshots",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        if (ctx2.options.fetchResults) {
          startPolling(ctx2, "", false, "");
        }
        updateLogContext({ task: "capture" });
        if (ctx2.options.parallel) {
          let { totalCapturedScreenshots, output } = yield captureScreenshotsConcurrent(ctx2);
          if (totalCapturedScreenshots != ctx2.webStaticConfig.length) {
            throw new Error(output);
          }
        } else {
          let { capturedScreenshots, output } = yield captureScreenshots(ctx2);
          if (capturedScreenshots != ctx2.webStaticConfig.length) {
            throw new Error(output);
          }
        }
        task.title = "Screenshots captured successfully";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(`${error.message}`);
        throw new Error("Capturing screenshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};

// src/commander/capture.ts
var command2 = new commander.Command();
command2.name("capture").description("Capture screenshots of static sites").argument("<file>", "Web static config file").option("-C, --parallel [number]", "Specify the number of instances per browser", parseInt).option("-F, --force", "forcefully apply the specified parallel instances per browser").option("--fetch-results [filename]", "Fetch results and optionally specify an output file, e.g., <filename>.json").option("--buildName <string>", "Specify the build name").option("--userName <string>", "Specify the LT username").option("--accessKey <string>", "Specify the LT accesskey").action(function(file, _, command9) {
  return __async(this, null, function* () {
    var _a, _b;
    const options = command9.optsWithGlobals();
    if (options.buildName === "") {
      console.log(`Error: The '--buildName' option cannot be an empty string.`);
      process.exit(1);
    }
    let ctx = ctx_default(command9.optsWithGlobals());
    ctx.isSnapshotCaptured = true;
    if (!fs5__default.default.existsSync(file)) {
      ctx.log.error(`Web Static Config file ${file} not found.`);
      return;
    }
    try {
      ctx.webStaticConfig = JSON.parse(fs5__default.default.readFileSync(file, "utf8"));
      if (!validateWebStaticConfig(ctx.webStaticConfig)) {
        ctx.log.debug(JSON.stringify(validateWebStaticConfig.errors, null, 2));
        (_a = validateWebStaticConfig.errors) == null ? void 0 : _a.forEach((error) => {
          if (error.keyword === "additionalProperties") {
            ctx.log.warn(`Additional property "${error.params.additionalProperty}" is not allowed.`);
          } else {
            const validationError = error.message;
            throw new Error(validationError || "Invalid Web Static config found in file : " + file);
          }
        });
        throw new Error((_b = validateWebStaticConfig.errors[0]) == null ? void 0 : _b.message);
      }
      if (ctx.webStaticConfig && ctx.webStaticConfig.length === 0) {
        ctx.log.error(`No URLs found in the specified config file -> ${file}`);
        return;
      }
    } catch (error) {
      ctx.log.error(`Invalid Web Static Config; ${error.message}`);
      return;
    }
    ctx.log.debug(ctx.config);
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        createBuild_default(),
        captureScreenshots_default(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    }
  });
});
var capture_default = command2;
var uploadScreenshots_default = (ctx) => {
  return {
    title: "Uploading screenshots",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        if (ctx2.options.fetchResults) {
          startPolling(ctx2, "", false, "");
        }
        updateLogContext({ task: "upload" });
        yield uploadScreenshots(ctx2);
        task.title = "Screenshots uploaded successfully";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(`${error.message}`);
        throw new Error("Uploading screenshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};

// src/commander/upload.ts
var command3 = new commander.Command();
command3.name("upload").description("Upload screenshots from given directory").argument("<directory>", "Path of the directory").option("-R, --ignoreResolutions", "Ignore resolution").option("-F, --files <extensions>", "Comma-separated list of allowed file extensions", (val) => {
  return val.split(",").map((ext) => ext.trim().toLowerCase());
}).option("-E, --removeExtensions", "Strips file extensions from snapshot names").option("-i, --ignoreDir <patterns>", "Comma-separated list of directories to ignore", (val) => {
  return val.split(",").map((pattern) => pattern.trim());
}).option("--fetch-results [filename]", "Fetch results and optionally specify an output file, e.g., <filename>.json").option("--buildName <string>", "Specify the build name").option("--userName <string>", "Specify the LT username").option("--accessKey <string>", "Specify the LT accesskey").action(function(directory, _, command9) {
  return __async(this, null, function* () {
    const options = command9.optsWithGlobals();
    if (options.buildName === "") {
      console.log(`Error: The '--buildName' option cannot be an empty string.`);
      process.exit(1);
    }
    let ctx = ctx_default(command9.optsWithGlobals());
    ctx.isSnapshotCaptured = true;
    if (!fs5__default.default.existsSync(directory)) {
      console.log(`Error: The provided directory ${directory} not found.`);
      return;
    }
    if (path2__default.default.extname(directory).toLowerCase() === constants_default.FILE_EXTENSION_ZIP) {
      ctx.log.debug(`Error: The provided directory ${directory} is a zip file. Zips are not accepted.`);
      return;
    }
    ctx.uploadFilePath = directory;
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        createBuild_default(),
        uploadScreenshots_default(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    }
  });
});
var upload_default = command3;

// src/lib/uploadFigmaDesigns.ts
var uploadFigmaDesigns_default = (ctx) => __async(void 0, null, function* () {
  const depth = ctx.figmaDesignConfig.depth;
  const figmaConfigs = ctx.figmaDesignConfig.figma_config;
  let results = "";
  let figmaFileToken = "";
  const markBaseline = ctx.options.markBaseline;
  const buildName = ctx.options.buildName;
  for (const config of figmaConfigs) {
    figmaFileToken = config.figma_file_token;
    let queryParams = "";
    if (config.figma_ids && config.figma_ids.length > 0) {
      const fileIds = config.figma_ids.join(",");
      queryParams += `?ids=${fileIds}`;
    }
    const authToken = `Basic ${Buffer.from(`${ctx.env.LT_USERNAME}:${ctx.env.LT_ACCESS_KEY}`).toString("base64")}`;
    const responseData = yield ctx.client.getFigmaFilesAndImages(figmaFileToken, ctx.env.FIGMA_TOKEN, queryParams, authToken, depth, markBaseline, buildName, ctx.log);
    if (responseData.data.message == "success") {
      results = responseData.data.message;
    }
  }
  return results;
});

// src/tasks/uploadFigmaDesigns.ts
var uploadFigmaDesigns_default2 = (ctx) => {
  return {
    title: "Uploading Figma Designs",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        updateLogContext({ task: "upload-figma" });
        let results = yield uploadFigmaDesigns_default(ctx2);
        if (results != "success") {
          throw new Error("Uploading Figma designs failed");
        }
        task.title = "Figma designs images uploaded successfully to SmartUI";
        ctx2.log.debug(`Figma designs processed: ${results}`);
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(`${error.message}`);
        throw new Error("Uploading Figma designs failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};

// src/lib/uploadWebFigma.ts
var uploadWebFigma_default = (ctx) => __async(void 0, null, function* () {
  var _a, _b;
  const figmaConfig = ctx.config && ((_a = ctx.config) == null ? void 0 : _a.figma) || {};
  const webConfig = ctx.config && ((_b = ctx.config) == null ? void 0 : _b.web) || {};
  let results = "";
  const buildName = ctx.options.buildName;
  if (figmaConfig && figmaConfig.configs && figmaConfig.configs.length > 0) {
    const authToken = `Basic ${Buffer.from(`${ctx.env.LT_USERNAME}:${ctx.env.LT_ACCESS_KEY}`).toString("base64")}`;
    const requestBody = {
      figma_token: ctx.env.FIGMA_TOKEN,
      auth: authToken,
      build_name: buildName,
      web: webConfig,
      figma: figmaConfig,
      smartIgnore: ctx.config.smartIgnore,
      git: ctx.git
    };
    const responseData = yield ctx.client.processWebFigma(requestBody, ctx.log);
    ctx.log.debug("responseData : " + JSON.stringify(responseData));
    if (responseData && responseData.error && responseData.error.message) {
      throw new Error(responseData.error.message);
    }
    if (responseData.data.message == "success") {
      results = responseData.data.message;
      ctx.build = {
        id: responseData.data.buildId,
        url: responseData.data.buildURL || "https://smartui.lambdatestinternal.com",
        baseline: responseData.data.baseline ? responseData.data.baseline : false
      };
    }
  } else {
    throw new Error("No Figma configuration found in config file");
  }
  return results;
});

// src/lib/fetchFigma.ts
var fetchFigma_default = (ctx) => __async(void 0, null, function* () {
  const buildId = ctx.build.id;
  ctx.log.debug(`Fetching figma results for buildId ${buildId}`);
  const startTime = Date.now();
  try {
    const results = yield callFetchWebFigmaRecursive(startTime, buildId, ctx);
    return results;
  } catch (error) {
    ctx.log.error(`Failed to fetch figma results: ${error}`);
    return { message: "Failed to fetch figma results" };
  }
});
function callFetchWebFigmaRecursive(startTime, buildId, ctx) {
  return __async(this, null, function* () {
    var _a, _b;
    const currentTime = Date.now();
    const elapsedTime = (currentTime - startTime) / 1e3;
    if (elapsedTime >= 180) {
      ctx.log.error("Stopping execution after 5 minutes.");
      throw new Error("Timeout: Fetching figma results took more than 5 minutes.");
    }
    try {
      const response = yield ctx.client.fetchWebFigma(buildId, ctx.log);
      ctx.log.debug("responseData : " + JSON.stringify(response));
      const message = ((_a = response == null ? void 0 : response.data) == null ? void 0 : _a.message) || "";
      if (message === "") {
        ctx.log.debug("No results yet. Retrying after 5 seconds...");
        yield new Promise((resolve) => setTimeout(resolve, 5e3));
        return yield callFetchWebFigmaRecursive(startTime, buildId, ctx);
      } else {
        return (_b = response == null ? void 0 : response.data) == null ? void 0 : _b.message;
      }
    } catch (error) {
      ctx.log.error("Error in fetchWebFigma:", error);
      ctx.log.debug("Retrying after 5 seconds...");
      yield new Promise((resolve) => setTimeout(resolve, 5e3));
      return yield callFetchWebFigmaRecursive(startTime, buildId, ctx);
    }
  });
}

// src/tasks/uploadWebFigma.ts
var uploadWebFigma_default2 = (ctx) => {
  return {
    title: "Processing Web Figma",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        updateLogContext({ task: "upload-figma-web" });
        let results = yield uploadWebFigma_default(ctx2);
        if (results != "success") {
          throw new Error("Uploading Web Figma Screenshot failed");
        }
        if (ctx2.build.id) {
          task.output = chalk__default.default.gray(`Build Id: ${ctx2.build.id}`);
          let figmaOutput = yield fetchFigma_default(ctx2);
          const jsonObject = JSON.parse(figmaOutput);
          let output = JSON.stringify(jsonObject, null, 2);
          task.output = task.output + "\n" + chalk__default.default.green(`${output}`);
        }
        if (ctx2.options.fetchResults) {
          startPolling(ctx2, "", false, "");
        }
        task.title = "Web Figma images uploaded successfully to SmartUI";
        ctx2.log.debug(`Web Figma processed: ${results}`);
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(`${error.message}`);
        throw new Error("Uploading Web Figma Screenshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: true
  };
};

// src/lib/uploadAppFigma.ts
var uploadAppFigma_default = (ctx) => __async(void 0, null, function* () {
  var _a, _b;
  const figmaConfig = ctx.config && ((_a = ctx.config) == null ? void 0 : _a.figma) || {};
  const mobileConfig = ctx.config && ((_b = ctx.config) == null ? void 0 : _b.mobile) || {};
  let results = "";
  const buildName = ctx.options.buildName;
  if (figmaConfig && figmaConfig.configs && figmaConfig.configs.length > 0) {
    const authToken = `Basic ${Buffer.from(`${ctx.env.LT_USERNAME}:${ctx.env.LT_ACCESS_KEY}`).toString("base64")}`;
    const requestBody = {
      figma_token: ctx.env.FIGMA_TOKEN,
      auth: authToken,
      build_name: buildName,
      mobile: mobileConfig,
      figma: figmaConfig,
      smartIgnore: ctx.config.smartIgnore,
      git: ctx.git,
      platformType: "app"
    };
    const responseData = yield ctx.client.processWebFigma(requestBody, ctx.log);
    ctx.log.debug("responseData : " + JSON.stringify(responseData));
    if (responseData && responseData.error && responseData.error.message) {
      throw new Error(responseData.error.message);
    }
    if (responseData.data.message == "success") {
      results = responseData.data.message;
      ctx.build = {
        id: responseData.data.buildId,
        url: responseData.data.buildURL || "https://smartui.lambdatestinternal.com",
        baseline: responseData.data.baseline ? responseData.data.baseline : false
      };
    }
  } else {
    throw new Error("No Figma configuration found in config file");
  }
  return results;
});

// src/tasks/uploadAppFigma.ts
var uploadAppFigma_default2 = (ctx) => {
  return {
    title: "Processing App Figma",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        updateLogContext({ task: "upload-figma-app" });
        let results = yield uploadAppFigma_default(ctx2);
        if (results != "success") {
          throw new Error("Uploading App Figma Screenshot failed");
        }
        if (ctx2.build.id) {
          task.output = chalk__default.default.gray(`Build Id: ${ctx2.build.id}`);
          let figmaOutput = yield fetchFigma_default(ctx2);
          const jsonObject = JSON.parse(figmaOutput);
          let output = JSON.stringify(jsonObject, null, 2);
          task.output = task.output + "\n" + chalk__default.default.green(`${output}`);
        }
        if (ctx2.options.fetchResults) {
          startPolling(ctx2, "", false, "");
        }
        task.title = "App Figma images uploaded successfully to SmartUI";
        ctx2.log.debug(`App Figma processed: ${results}`);
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(`${error.message}`);
        throw new Error("Uploading App Figma Screenshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: true
  };
};
var uploadFigma = new commander.Command();
var uploadWebFigmaCommand = new commander.Command();
var uploadAppFigmaCommand = new commander.Command();
uploadFigma.name("upload-figma").description("Capture screenshots of static sites").argument("<file>", "figma design config file").option("--markBaseline", "Mark the uploaded images as baseline").option("--buildName <buildName>", "Name of the build").action(function(file, _, command9) {
  return __async(this, null, function* () {
    var _a, _b;
    let ctx = ctx_default(command9.optsWithGlobals());
    ctx.isSnapshotCaptured = true;
    if (!fs5__default.default.existsSync(file)) {
      console.log(`Error: Figma Config file ${file} not found.`);
      return;
    }
    try {
      ctx.figmaDesignConfig = JSON.parse(fs5__default.default.readFileSync(file, "utf8"));
      if (!validateFigmaDesignConfig(ctx.figmaDesignConfig)) {
        const validationError = (_b = (_a = validateFigmaDesignConfig.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.message;
        throw new Error(validationError || "Invalid figma design Config");
      }
    } catch (error) {
      console.log(`[smartui] Error: Invalid figma design Config; ${error.message}`);
      return;
    }
    let tasks = new listr2.Listr(
      [
        auth_default(),
        uploadFigmaDesigns_default2()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    }
  });
});
uploadWebFigmaCommand.name("upload-figma-web").description("Capture figma screenshots into CLI build").argument("<file>", "figma config config file").option("--markBaseline", "Mark the uploaded images as baseline").option("--buildName <buildName>", "Name of the build").option("--fetch-results [filename]", "Fetch results and optionally specify an output file, e.g., <filename>.json").action(function(file, _, command9) {
  return __async(this, null, function* () {
    var _a;
    let ctx = ctx_default(command9.optsWithGlobals());
    if (!fs5__default.default.existsSync(file)) {
      console.log(`Error: figma-web config file ${file} not found.`);
      return;
    }
    try {
      ctx.config = JSON.parse(fs5__default.default.readFileSync(file, "utf8"));
      ctx.log.info(JSON.stringify(ctx.config));
      if (!validateWebFigmaConfig(ctx.config)) {
        ctx.log.debug(JSON.stringify(validateWebFigmaConfig.errors, null, 2));
        (_a = validateWebFigmaConfig.errors) == null ? void 0 : _a.forEach((error) => {
          if (error.keyword === "additionalProperties") {
            ctx.log.warn(`Additional property "${error.params.additionalProperty}" is not allowed.`);
          } else {
            const validationError = error.message;
            throw new Error(validationError || "Invalid figma-web config found in file : " + file);
          }
        });
      }
      verifyFigmaWebConfig(ctx);
    } catch (error) {
      ctx.log.error(chalk__default.default.red(`Invalid figma-web config; ${error.message}`));
      return;
    }
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        uploadWebFigma_default2(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    }
  });
});
uploadAppFigmaCommand.name("upload-figma-app").description("Capture figma screenshots into App Build").argument("<file>", "figma config config file").option("--markBaseline", "Mark the uploaded images as baseline").option("--buildName <buildName>", "Name of the build").option("--fetch-results [filename]", "Fetch results and optionally specify an output file, e.g., <filename>.json").action(function(file, _, command9) {
  return __async(this, null, function* () {
    var _a;
    let ctx = ctx_default(command9.optsWithGlobals());
    if (!fs5__default.default.existsSync(file)) {
      console.log(`Error: figma-app config file ${file} not found.`);
      return;
    }
    try {
      ctx.config = JSON.parse(fs5__default.default.readFileSync(file, "utf8"));
      ctx.log.info(JSON.stringify(ctx.config));
      if (!validateAppFigmaConfig(ctx.config)) {
        ctx.log.debug(JSON.stringify(validateAppFigmaConfig.errors, null, 2));
        (_a = validateAppFigmaConfig.errors) == null ? void 0 : _a.forEach((error) => {
          if (error.keyword === "additionalProperties") {
            ctx.log.warn(`Additional property "${error.params.additionalProperty}" is not allowed.`);
          } else {
            const validationError = error.message;
            throw new Error(validationError || "Invalid figma-app config found in file : " + file);
          }
        });
      }
      verifyFigmaWebConfig(ctx);
    } catch (error) {
      ctx.log.error(chalk__default.default.red(`Invalid figma-app config; ${error.message}`));
      return;
    }
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        uploadAppFigma_default2(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    }
  });
});
var command4 = new commander.Command();
command4.name("exec:start").description("Start SmartUI server").option("-P, --port <number>", "Port number for the server").option("--fetch-results [filename]", "Fetch results and optionally specify an output file, e.g., <filename>.json").option("--buildName <string>", "Specify the build name").action(function() {
  return __async(this, null, function* () {
    const options = command4.optsWithGlobals();
    if (options.buildName === "") {
      console.log(`Error: The '--buildName' option cannot be an empty string.`);
      process.exit(1);
    }
    let ctx = ctx_default(command4.optsWithGlobals());
    ctx.snapshotQueue = new Queue(ctx);
    ctx.totalSnapshots = 0;
    ctx.isStartExec = true;
    let tasks = new listr2.Listr(
      [
        auth_default(),
        startServer_default(),
        getGitInfo_default(),
        createBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
      startPingPolling(ctx);
      if (ctx.options.fetchResults) {
        startPolling(ctx, "", false, "");
      }
    } catch (error) {
      console.error("Error during server execution:", error);
    }
  });
});
var server_default2 = command4;
var command5 = new commander.Command();
function getSmartUIServerAddress() {
  const serverAddress = process.env.SMARTUI_SERVER_ADDRESS || "http://localhost:49152";
  return serverAddress;
}
command5.name("exec:stop").description("Stop the SmartUI server").action(function() {
  return __async(this, null, function* () {
    try {
      const serverAddress = getSmartUIServerAddress();
      console.log(chalk__default.default.yellow(`Stopping server at ${serverAddress} from terminal...`));
      const response = yield axios__default.default.post(`${serverAddress}/stop`, { timeout: 15e3 }, {
        headers: {
          "Content-Type": "application/json"
          // Ensure the correct Content-Type header
        }
      });
      if (response.status === 200) {
        console.log(chalk__default.default.green("Server stopped successfully"));
        console.log(chalk__default.default.green(`Response: ${JSON.stringify(response.data)}`));
      } else {
        console.log(chalk__default.default.red("Failed to stop server"));
      }
    } catch (error) {
      if (error.code === "ECONNABORTED") {
        console.error(chalk__default.default.red("Error: SmartUI server did not respond in 15 seconds"));
      } else {
        console.error(chalk__default.default.red("Error while stopping server"));
      }
    }
  });
});
var stopServer_default = command5;
function getSmartUIServerAddress2() {
  const serverAddress = process.env.SMARTUI_SERVER_ADDRESS || "http://localhost:49152";
  return serverAddress;
}
var command6 = new commander.Command();
command6.name("exec:ping").description("Ping the SmartUI server to check if it is running").action(function() {
  return __async(this, null, function* () {
    try {
      console.log(chalk__default.default.yellow("Pinging server..."));
      const serverAddress = getSmartUIServerAddress2();
      console.log(chalk__default.default.yellow(`Pinging server at ${serverAddress} from terminal...`));
      const response = yield axios__default.default.get(`${serverAddress}/ping`, { timeout: 15e3 });
      if (response.status === 200) {
        console.log(chalk__default.default.green("SmartUI Server is running"));
        console.log(chalk__default.default.green(`Response: ${JSON.stringify(response.data)}`));
      } else {
        console.log(chalk__default.default.red("Failed to reach the server"));
      }
    } catch (error) {
      if (error.code === "ECONNABORTED") {
        console.error(chalk__default.default.red("Error: SmartUI server did not respond in 15 seconds"));
      } else {
        console.error(chalk__default.default.red("SmartUI server is not running"));
      }
    }
  });
});
var ping_default = command6;
var fetchBranchInfo_default = (ctx) => {
  return {
    title: `Fetching branch info`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "fetchBranchInfo" });
      try {
        if (ctx2.mergeBranchSource === ctx2.mergeBranchTarget) {
          ctx2.log.error(`Merging two similar branch is not possible`);
          throw new Error(`Merging two similar branch is not possible`);
        }
        const requestData = {
          source: ctx2.mergeBranchSource,
          target: ctx2.mergeBranchTarget,
          byBranch: ctx2.mergeByBranch,
          byBuild: ctx2.mergeByBuild
        };
        let resp = yield ctx2.client.fetchBuildInfo(requestData, ctx2);
        if (resp && resp.data && resp.data.source && resp.data.target) {
          ctx2.mergeBuildSourceId = resp.data.source;
          ctx2.mergeBuildTargetId = resp.data.target;
          ctx2.log.debug(`Merge Build source buildId: ${ctx2.mergeBuildSourceId} and target buildId: ${ctx2.mergeBuildTargetId}`);
        } else if (resp && resp.error) {
          if (resp.error.message) {
            ctx2.log.error(`Error while fetching branch Info: ${resp.error.message}`);
            throw new Error(`Error while fetching branch Info: ${resp.error.message}`);
          }
        }
        task.title = "Branch info fetched";
        task.output = chalk__default.default.gray(`Source buildId: ${ctx2.mergeBuildSourceId} and Target buildId: ${ctx2.mergeBuildTargetId}`);
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Branch info fetching failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var mergeBuilds_default = (ctx) => {
  return {
    title: `Merging smartui builds`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "mergeBuilds" });
      try {
        let resp;
        if (ctx2.mergeByBranch) {
          ctx2.git.branch = ctx2.mergeBranchTarget;
          const requestData = {
            source: ctx2.mergeBuildSourceId,
            target: ctx2.mergeBuildTargetId,
            byBranch: ctx2.mergeByBranch,
            byBuildName: ctx2.mergeByBuild,
            sourceBranchName: ctx2.mergeBranchSource,
            targetBranchName: ctx2.mergeBranchTarget,
            sourceBuildName: "",
            targetBuildName: "",
            git: ctx2.git
          };
          resp = yield ctx2.client.mergeBuildsByBuildId(requestData, ctx2);
        } else {
          const requestData = {
            source: ctx2.mergeBuildSourceId,
            target: ctx2.mergeBuildTargetId,
            byBranch: ctx2.mergeByBranch,
            byBuildName: ctx2.mergeByBuild,
            sourceBranchName: "",
            targetBranchName: "",
            sourceBuildName: ctx2.mergeBuildSource,
            targetBuildName: ctx2.mergeBuildTarget,
            git: ctx2.git
          };
          resp = yield ctx2.client.mergeBuildsByBuildId(requestData, ctx2);
        }
        if (resp && resp.data && resp.data.message) {
          ctx2.log.debug(`${resp.data.message}`);
        } else {
          ctx2.log.error(`Error while initiating merging process: ${resp.error.message}`);
          throw new Error(`Error while initiating merging process: ${resp.error.message}`);
        }
        task.title = "Merging SmartUI builds initiated";
        task.output = chalk__default.default.gray(`${resp.data.message}`);
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Merging SmartUI build failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};

// src/commander/mergeBranch.ts
var command7 = new commander.Command();
command7.name("branch").description("Merge a source branch into the target branch").requiredOption("--source <string>", "Source branch to merge").requiredOption("--target <string>", "Target branch to merge into").action(function(options) {
  return __async(this, null, function* () {
    const { source, target } = options;
    let ctx = ctx_default(command7.optsWithGlobals());
    if (!source || source.trim() === "") {
      ctx.log.error("Error: The --source option cannot be empty.");
      process.exit(1);
    }
    if (!target || target.trim() === "") {
      ctx.log.error("Error: The --target option cannot be empty.");
      process.exit(1);
    }
    ctx.log.debug(`Merging source branch '${source}' into branch branch '${target}'`);
    ctx.mergeBranchSource = source;
    ctx.mergeBranchTarget = target;
    ctx.mergeByBranch = true;
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        fetchBranchInfo_default(),
        mergeBuilds_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: "\u2192"
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.error("Error during merge operation:", error);
    }
  });
});
var mergeBranch_default = command7;
var fetchBuildInfo_default = (ctx) => {
  return {
    title: `Fetching build info`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "fetchBuildInfo" });
      try {
        if (ctx2.mergeBuildSource === ctx2.mergeBuildTarget) {
          ctx2.log.error(`Merging two similar build is not possible`);
          throw new Error(`Merging two similar build is not possible`);
        }
        const requestData = {
          source: ctx2.mergeBuildSource,
          target: ctx2.mergeBuildTarget,
          byBranch: ctx2.mergeByBranch,
          byBuildName: ctx2.mergeByBuild
        };
        let resp = yield ctx2.client.fetchBuildInfo(requestData, ctx2);
        if (resp && resp.data && resp.data.source && resp.data.target) {
          ctx2.mergeBuildSourceId = resp.data.source;
          ctx2.mergeBuildTargetId = resp.data.target;
          ctx2.log.debug(`Merge Build source buildId: ${ctx2.mergeBuildSourceId} and target buildId: ${ctx2.mergeBuildTargetId}`);
        } else if (resp && resp.error) {
          if (resp.error.message) {
            ctx2.log.error(`Error while fetching buildInfo: ${resp.error.message}`);
            throw new Error(`Error while fetching buildInfo: ${resp.error.message}`);
          }
        }
        task.title = "Build info fetched";
        task.output = chalk__default.default.gray(`Source buildId: ${ctx2.mergeBuildSourceId} and Target buildId: ${ctx2.mergeBuildTargetId}`);
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Build info fetching failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};

// src/commander/mergeBuild.ts
var command8 = new commander.Command();
command8.name("build").description("Merge a source build into the target build").requiredOption("--source <string>", "Source build to merge").requiredOption("--target <string>", "Target build to merge into").action(function(options) {
  return __async(this, null, function* () {
    const { source, target } = options;
    let ctx = ctx_default(command8.optsWithGlobals());
    if (!source || source.trim() === "") {
      ctx.log.error("Error: The --source option cannot be empty.");
      process.exit(1);
    }
    if (!target || target.trim() === "") {
      ctx.log.error("Error: The --target option cannot be empty.");
      process.exit(1);
    }
    ctx.log.debug(`Merging source build '${source}' into target build '${target}'`);
    ctx.mergeBuildSource = source;
    ctx.mergeBuildTarget = target;
    ctx.mergeByBuild = true;
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        fetchBuildInfo_default(),
        mergeBuilds_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: "\u2192"
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.error("Error during merge operation:", error);
    }
  });
});
var mergeBuild_default = command8;

// src/commander/merge.ts
var program = new commander.Command();
program.name("merge").description("Merge a source branch into the target branch").addCommand(mergeBranch_default).addCommand(mergeBuild_default);
var merge_default = program;

// src/commander/commander.ts
var program2 = new commander.Command();
program2.name("smartui").description("CLI to help you run your SmartUI tests on LambdaTest platform").version(`v${version}`).option("-c --config <filepath>", "Config file path").option("--markBaseline", "Mark this build baseline").option("--baselineBranch <string>", "Mark this build baseline").option("--baselineBuild <string>", "Mark this build baseline").addCommand(exec_default2).addCommand(capture_default).addCommand(configWeb).addCommand(configStatic).addCommand(upload_default).addCommand(server_default2).addCommand(stopServer_default).addCommand(merge_default).addCommand(ping_default).addCommand(configFigma).addCommand(uploadFigma).addCommand(configWebFigma).addCommand(configAppFigma).addCommand(uploadWebFigmaCommand).addCommand(uploadAppFigmaCommand);
var commander_default = program2;
(function() {
  return __async(this, null, function* () {
    let client = new httpClient(env_default());
    let log2 = logger_default;
    try {
      fs5__default.default.unlinkSync(constants_default.LOG_FILE_PATH);
      let { data: { latestVersion, deprecated, additionalDescription } } = yield client.checkUpdate(log2);
      log2.info(`
LambdaTest SmartUI CLI v${package_default.version}`);
      log2.info(chalk__default.default.yellow(`${additionalDescription}`));
      if (deprecated) {
        log2.warn(`This version is deprecated. A new version ${latestVersion} is available!`);
      } else if (package_default.version !== latestVersion) {
        log2.info(chalk__default.default.green(`A new version ${latestVersion} is available!`));
      } else
        log2.info(chalk__default.default.gray("https://www.npmjs.com/package/@lambdatest/smartui-cli\n"));
    } catch (error) {
      log2.debug(error);
      log2.info(chalk__default.default.gray("https://www.npmjs.com/package/@lambdatest/smartui-cli\n"));
    }
    commander_default.parse();
  });
})();
